Grammar:

Rule 0     S' -> program
Rule 1     program -> decl_list
Rule 2     decl_list -> decl
Rule 3     decl_list -> decl_list decl
Rule 4     decl -> class_decl
Rule 5     decl -> func_decl
Rule 6     decl -> var_decl
Rule 7     type_spec -> TYPE_SPECIFIER
Rule 8     var_decl -> type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
Rule 9     var_decl -> type_spec IDENTIFIER SEMICOLON
Rule 10    func_decl -> type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
Rule 11    params -> empty
Rule 12    params -> param_list
Rule 13    param_list -> param _1_COMMA_param_repeat
Rule 14    _1_COMMA_param_repeat -> _1_COMMA_param_items
Rule 15    _1_COMMA_param_repeat -> <empty>
Rule 16    _1_COMMA_param_items -> _1_COMMA_param_items _1_COMMA_param_item
Rule 17    _1_COMMA_param_items -> _1_COMMA_param_item
Rule 18    _1_COMMA_param_item -> COMMA param
Rule 19    param -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET
Rule 20    param -> TYPE_SPECIFIER IDENTIFIER
Rule 21    compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE
Rule 22    local_decls -> empty
Rule 23    local_decls -> local_decl
Rule 24    local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
Rule 25    local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON
Rule 26    stmt_list -> _2_stmt_repeat
Rule 27    _2_stmt_repeat -> _2_stmt_items
Rule 28    _2_stmt_repeat -> <empty>
Rule 29    _2_stmt_items -> _2_stmt_items _2_stmt_item
Rule 30    _2_stmt_items -> _2_stmt_item
Rule 31    _2_stmt_item -> stmt
Rule 32    stmt -> size_stmt
Rule 33    stmt -> continue_stmt
Rule 34    stmt -> break_stmt
Rule 35    stmt -> return_stmt
Rule 36    stmt -> while_stmt
Rule 37    stmt -> if_stmt
Rule 38    stmt -> compound_stmt
Rule 39    stmt -> expr_stmt
Rule 40    expr_stmt -> SEMICOLON
Rule 41    expr_stmt -> expr SEMICOLON
Rule 42    if_stmt -> IF ( expr ) stmt ELSE stmt  [precedence=right, level=1]
Rule 43    if_stmt -> IF ( expr ) stmt  [precedence=right, level=1]
Rule 44    while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt
Rule 45    return_stmt -> RETURN expr SEMICOLON
Rule 46    return_stmt -> RETURN SEMICOLON
Rule 47    break_stmt -> BREAK SEMICOLON
Rule 48    printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
Rule 49    _3_COMMA_expr_repeat -> _3_COMMA_expr_items
Rule 50    _3_COMMA_expr_repeat -> <empty>
Rule 51    _3_COMMA_expr_items -> _3_COMMA_expr_items _3_COMMA_expr_item
Rule 52    _3_COMMA_expr_items -> _3_COMMA_expr_item
Rule 53    _3_COMMA_expr_item -> COMMA expr
Rule 54    printf_call -> printf_stmt
Rule 55    continue_stmt -> CONTINUE SEMICOLON
Rule 56    size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
Rule 57    expr -> printf_call
Rule 58    expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
Rule 59    expr -> STRING_LITERAL
Rule 60    expr -> FLOAT_LITERAL
Rule 61    expr -> INT_LITERAL
Rule 62    expr -> BOOL_LITERAL
Rule 63    expr -> IDENTIFIER DOT SIZE
Rule 64    expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN
Rule 65    expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
Rule 66    expr -> IDENTIFIER
Rule 67    expr -> LEFT_PAREN expr RIGHT_PAREN
Rule 68    expr -> PLUS expr  [precedence=right, level=9]
Rule 69    expr -> MINUS expr  [precedence=right, level=9]
Rule 70    expr -> NOT expr  [precedence=right, level=9]
Rule 71    expr -> expr MOD expr  [precedence=left, level=8]
Rule 72    expr -> expr DIVIDE expr  [precedence=left, level=8]
Rule 73    expr -> expr TIMES expr  [precedence=left, level=8]
Rule 74    expr -> expr MINUS expr  [precedence=left, level=7]
Rule 75    expr -> expr PLUS expr  [precedence=left, level=7]
Rule 76    expr -> expr GREATER_EQUAL expr  [precedence=left, level=6]
Rule 77    expr -> expr GREATER expr  [precedence=left, level=6]
Rule 78    expr -> expr LESS_EQUAL expr  [precedence=left, level=6]
Rule 79    expr -> expr LESS expr  [precedence=left, level=6]
Rule 80    expr -> expr NOT_EQUAL expr  [precedence=left, level=5]
Rule 81    expr -> expr EQUAL expr  [precedence=left, level=5]
Rule 82    expr -> expr AND expr  [precedence=left, level=4]
Rule 83    expr -> expr OR expr  [precedence=left, level=3]
Rule 84    expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr  [precedence=right, level=2]
Rule 85    expr -> IDENTIFIER ASSIGN expr  [precedence=right, level=2]
Rule 86    args -> empty
Rule 87    args -> arg_list
Rule 88    arg_list -> expr _4_COMMA_expr_optional
Rule 89    _4_COMMA_expr_optional -> COMMA expr
Rule 90    _4_COMMA_expr_optional -> <empty>
Rule 91    class_decl -> CLASS IDENTIFIER COLON inheritance_list class_content
Rule 92    class_decl -> CLASS IDENTIFIER class_content
Rule 93    class_content -> LEFT_BRACE _5_members_decl_optional RIGHT_BRACE SEMICOLON
Rule 94    _5_members_decl_optional -> members_decl
Rule 95    _5_members_decl_optional -> <empty>
Rule 96    inheritance_list -> inheritance _6_COMMA_inheritance_optional
Rule 97    _6_COMMA_inheritance_optional -> COMMA inheritance
Rule 98    _6_COMMA_inheritance_optional -> <empty>
Rule 99    inheritance -> IDENTIFIER
Rule 100   inheritance -> access_specifier IDENTIFIER
Rule 101   access_specifier -> ACCESS_SPECIFIER
Rule 102   members_decl -> access_specifier COLON members_list
Rule 103   members_list -> var_decl
Rule 104   members_list -> func_decl
Rule 105   members_list -> constructor_decl
Rule 106   members_list -> destructor_decl
Rule 107   constructor_decl -> IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
Rule 108   destructor_decl -> ~ IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_stmt
Rule 109   empty -> <empty>

Terminals, with rules where they appear:

(                    : 42 43
)                    : 42 43
ACCESS_SPECIFIER     : 101
AND                  : 82
ASSIGN               : 84 85
BOOL_LITERAL         : 62
BREAK                : 47
CLASS                : 91 92
COLON                : 91 102
COMMA                : 18 53 89 97
CONTINUE             : 55
DIVIDE               : 72
DOT                  : 63
ELSE                 : 42
EQUAL                : 81
FLOAT_LITERAL        : 60
GREATER              : 77
GREATER_EQUAL        : 76
IDENTIFIER           : 8 9 10 19 20 24 25 63 64 65 66 84 85 91 92 99 100 107 108
IF                   : 42 43
INT_LITERAL          : 61
LEFT_BRACE           : 21 93
LEFT_BRACKET         : 8 19 24 58 65 84
LEFT_PAREN           : 10 44 48 56 64 67 107 108
LESS                 : 79
LESS_EQUAL           : 78
MINUS                : 69 74
MOD                  : 71
NEW                  : 58
NOT                  : 70
NOT_EQUAL            : 80
OR                   : 83
PLUS                 : 68 75
PRINTF               : 48
RETURN               : 45 46
RIGHT_BRACE          : 21 93
RIGHT_BRACKET        : 8 19 24 58 65 84
RIGHT_PAREN          : 10 44 48 56 64 67 107 108
SEMICOLON            : 8 9 24 25 40 41 45 46 47 48 55 56 93
SIZE                 : 56 63
STRING_LITERAL       : 48 59
TIMES                : 73
TYPE_SPECIFIER       : 7 19 20 24 25 58
WHILE                : 44
error                : 
~                    : 108

Nonterminals, with rules where they appear:

_1_COMMA_param_item  : 16 17
_1_COMMA_param_items : 14 16
_1_COMMA_param_repeat : 13
_2_stmt_item         : 29 30
_2_stmt_items        : 27 29
_2_stmt_repeat       : 26
_3_COMMA_expr_item   : 51 52
_3_COMMA_expr_items  : 49 51
_3_COMMA_expr_repeat : 48
_4_COMMA_expr_optional : 88
_5_members_decl_optional : 93
_6_COMMA_inheritance_optional : 96
access_specifier     : 100 102
arg_list             : 87
args                 : 64
break_stmt           : 34
class_content        : 91 92
class_decl           : 4
compound_stmt        : 10 38 107 108
constructor_decl     : 105
continue_stmt        : 33
decl                 : 2 3
decl_list            : 1 3
destructor_decl      : 106
empty                : 11 22 86
expr                 : 41 42 43 44 45 53 56 58 65 67 68 69 70 71 71 72 72 73 73 74 74 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 88 89
expr_stmt            : 39
func_decl            : 5 104
if_stmt              : 37
inheritance          : 96 97
inheritance_list     : 91
local_decl           : 23
local_decls          : 21
members_decl         : 94
members_list         : 102
param                : 13 18
param_list           : 12
params               : 10 107
printf_call          : 57
printf_stmt          : 54
program              : 0
return_stmt          : 35
size_stmt            : 32
stmt                 : 31 42 42 43 44
stmt_list            : 21
type_spec            : 8 9 10
var_decl             : 6 103
while_stmt           : 36


state 0

    (0) S' -> . program
    (1) program -> . decl_list
    (2) decl_list -> . decl
    (3) decl_list -> . decl_list decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (91) class_decl -> . CLASS IDENTIFIER COLON inheritance_list class_content
    (92) class_decl -> . CLASS IDENTIFIER class_content
    (10) func_decl -> . type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
    (8) var_decl -> . type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (9) var_decl -> . type_spec IDENTIFIER SEMICOLON
    (7) type_spec -> . TYPE_SPECIFIER
    CLASS           shift and go to state 7
    TYPE_SPECIFIER  shift and go to state 9

    program                        shift and go to state 1
    decl_list                      shift and go to state 2
    decl                           shift and go to state 3
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 1

    (0) S' -> program .


state 2

    (1) program -> decl_list .
    (3) decl_list -> decl_list . decl
    (4) decl -> . class_decl
    (5) decl -> . func_decl
    (6) decl -> . var_decl
    (91) class_decl -> . CLASS IDENTIFIER COLON inheritance_list class_content
    (92) class_decl -> . CLASS IDENTIFIER class_content
    (10) func_decl -> . type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
    (8) var_decl -> . type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (9) var_decl -> . type_spec IDENTIFIER SEMICOLON
    (7) type_spec -> . TYPE_SPECIFIER
    $end            reduce using rule 1 (program -> decl_list .)
    CLASS           shift and go to state 7
    TYPE_SPECIFIER  shift and go to state 9

    decl                           shift and go to state 10
    class_decl                     shift and go to state 4
    func_decl                      shift and go to state 5
    var_decl                       shift and go to state 6
    type_spec                      shift and go to state 8

state 3

    (2) decl_list -> decl .
    CLASS           reduce using rule 2 (decl_list -> decl .)
    TYPE_SPECIFIER  reduce using rule 2 (decl_list -> decl .)
    $end            reduce using rule 2 (decl_list -> decl .)


state 4

    (4) decl -> class_decl .
    CLASS           reduce using rule 4 (decl -> class_decl .)
    TYPE_SPECIFIER  reduce using rule 4 (decl -> class_decl .)
    $end            reduce using rule 4 (decl -> class_decl .)


state 5

    (5) decl -> func_decl .
    CLASS           reduce using rule 5 (decl -> func_decl .)
    TYPE_SPECIFIER  reduce using rule 5 (decl -> func_decl .)
    $end            reduce using rule 5 (decl -> func_decl .)


state 6

    (6) decl -> var_decl .
    CLASS           reduce using rule 6 (decl -> var_decl .)
    TYPE_SPECIFIER  reduce using rule 6 (decl -> var_decl .)
    $end            reduce using rule 6 (decl -> var_decl .)


state 7

    (91) class_decl -> CLASS . IDENTIFIER COLON inheritance_list class_content
    (92) class_decl -> CLASS . IDENTIFIER class_content
    IDENTIFIER      shift and go to state 11


state 8

    (10) func_decl -> type_spec . IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
    (8) var_decl -> type_spec . IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (9) var_decl -> type_spec . IDENTIFIER SEMICOLON
    IDENTIFIER      shift and go to state 12


state 9

    (7) type_spec -> TYPE_SPECIFIER .
    IDENTIFIER      reduce using rule 7 (type_spec -> TYPE_SPECIFIER .)


state 10

    (3) decl_list -> decl_list decl .
    CLASS           reduce using rule 3 (decl_list -> decl_list decl .)
    TYPE_SPECIFIER  reduce using rule 3 (decl_list -> decl_list decl .)
    $end            reduce using rule 3 (decl_list -> decl_list decl .)


state 11

    (91) class_decl -> CLASS IDENTIFIER . COLON inheritance_list class_content
    (92) class_decl -> CLASS IDENTIFIER . class_content
    (93) class_content -> . LEFT_BRACE _5_members_decl_optional RIGHT_BRACE SEMICOLON
    COLON           shift and go to state 13
    LEFT_BRACE      shift and go to state 15

    class_content                  shift and go to state 14

state 12

    (10) func_decl -> type_spec IDENTIFIER . LEFT_PAREN params RIGHT_PAREN compound_stmt
    (8) var_decl -> type_spec IDENTIFIER . LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (9) var_decl -> type_spec IDENTIFIER . SEMICOLON
    LEFT_PAREN      shift and go to state 16
    LEFT_BRACKET    shift and go to state 17
    SEMICOLON       shift and go to state 18


state 13

    (91) class_decl -> CLASS IDENTIFIER COLON . inheritance_list class_content
    (96) inheritance_list -> . inheritance _6_COMMA_inheritance_optional
    (99) inheritance -> . IDENTIFIER
    (100) inheritance -> . access_specifier IDENTIFIER
    (101) access_specifier -> . ACCESS_SPECIFIER
    IDENTIFIER      shift and go to state 19
    ACCESS_SPECIFIER shift and go to state 23

    inheritance_list               shift and go to state 20
    inheritance                    shift and go to state 21
    access_specifier               shift and go to state 22

state 14

    (92) class_decl -> CLASS IDENTIFIER class_content .
    CLASS           reduce using rule 92 (class_decl -> CLASS IDENTIFIER class_content .)
    TYPE_SPECIFIER  reduce using rule 92 (class_decl -> CLASS IDENTIFIER class_content .)
    $end            reduce using rule 92 (class_decl -> CLASS IDENTIFIER class_content .)


state 15

    (93) class_content -> LEFT_BRACE . _5_members_decl_optional RIGHT_BRACE SEMICOLON
    (94) _5_members_decl_optional -> . members_decl
    (95) _5_members_decl_optional -> .
    (102) members_decl -> . access_specifier COLON members_list
    (101) access_specifier -> . ACCESS_SPECIFIER
    RIGHT_BRACE     reduce using rule 95 (_5_members_decl_optional -> .)
    ACCESS_SPECIFIER shift and go to state 23

    _5_members_decl_optional       shift and go to state 24
    members_decl                   shift and go to state 25
    access_specifier               shift and go to state 26

state 16

    (10) func_decl -> type_spec IDENTIFIER LEFT_PAREN . params RIGHT_PAREN compound_stmt
    (11) params -> . empty
    (12) params -> . param_list
    (109) empty -> .
    (13) param_list -> . param _1_COMMA_param_repeat
    (19) param -> . TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET
    (20) param -> . TYPE_SPECIFIER IDENTIFIER
    RIGHT_PAREN     reduce using rule 109 (empty -> .)
    TYPE_SPECIFIER  shift and go to state 31

    params                         shift and go to state 27
    empty                          shift and go to state 28
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 17

    (8) var_decl -> type_spec IDENTIFIER LEFT_BRACKET . RIGHT_BRACKET SEMICOLON
    RIGHT_BRACKET   shift and go to state 32


state 18

    (9) var_decl -> type_spec IDENTIFIER SEMICOLON .
    CLASS           reduce using rule 9 (var_decl -> type_spec IDENTIFIER SEMICOLON .)
    TYPE_SPECIFIER  reduce using rule 9 (var_decl -> type_spec IDENTIFIER SEMICOLON .)
    $end            reduce using rule 9 (var_decl -> type_spec IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 9 (var_decl -> type_spec IDENTIFIER SEMICOLON .)


state 19

    (99) inheritance -> IDENTIFIER .
    COMMA           reduce using rule 99 (inheritance -> IDENTIFIER .)
    LEFT_BRACE      reduce using rule 99 (inheritance -> IDENTIFIER .)


state 20

    (91) class_decl -> CLASS IDENTIFIER COLON inheritance_list . class_content
    (93) class_content -> . LEFT_BRACE _5_members_decl_optional RIGHT_BRACE SEMICOLON
    LEFT_BRACE      shift and go to state 15

    class_content                  shift and go to state 33

state 21

    (96) inheritance_list -> inheritance . _6_COMMA_inheritance_optional
    (97) _6_COMMA_inheritance_optional -> . COMMA inheritance
    (98) _6_COMMA_inheritance_optional -> .
    COMMA           shift and go to state 35
    LEFT_BRACE      reduce using rule 98 (_6_COMMA_inheritance_optional -> .)

    _6_COMMA_inheritance_optional  shift and go to state 34

state 22

    (100) inheritance -> access_specifier . IDENTIFIER
    IDENTIFIER      shift and go to state 36


state 23

    (101) access_specifier -> ACCESS_SPECIFIER .
    IDENTIFIER      reduce using rule 101 (access_specifier -> ACCESS_SPECIFIER .)
    COLON           reduce using rule 101 (access_specifier -> ACCESS_SPECIFIER .)


state 24

    (93) class_content -> LEFT_BRACE _5_members_decl_optional . RIGHT_BRACE SEMICOLON
    RIGHT_BRACE     shift and go to state 37


state 25

    (94) _5_members_decl_optional -> members_decl .
    RIGHT_BRACE     reduce using rule 94 (_5_members_decl_optional -> members_decl .)


state 26

    (102) members_decl -> access_specifier . COLON members_list
    COLON           shift and go to state 38


state 27

    (10) func_decl -> type_spec IDENTIFIER LEFT_PAREN params . RIGHT_PAREN compound_stmt
    RIGHT_PAREN     shift and go to state 39


state 28

    (11) params -> empty .
    RIGHT_PAREN     reduce using rule 11 (params -> empty .)


state 29

    (12) params -> param_list .
    RIGHT_PAREN     reduce using rule 12 (params -> param_list .)


state 30

    (13) param_list -> param . _1_COMMA_param_repeat
    (14) _1_COMMA_param_repeat -> . _1_COMMA_param_items
    (15) _1_COMMA_param_repeat -> .
    (16) _1_COMMA_param_items -> . _1_COMMA_param_items _1_COMMA_param_item
    (17) _1_COMMA_param_items -> . _1_COMMA_param_item
    (18) _1_COMMA_param_item -> . COMMA param
    RIGHT_PAREN     reduce using rule 15 (_1_COMMA_param_repeat -> .)
    COMMA           shift and go to state 43

    _1_COMMA_param_repeat          shift and go to state 40
    _1_COMMA_param_items           shift and go to state 41
    _1_COMMA_param_item            shift and go to state 42

state 31

    (19) param -> TYPE_SPECIFIER . IDENTIFIER LEFT_BRACKET RIGHT_BRACKET
    (20) param -> TYPE_SPECIFIER . IDENTIFIER
    IDENTIFIER      shift and go to state 44


state 32

    (8) var_decl -> type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET . SEMICOLON
    SEMICOLON       shift and go to state 45


state 33

    (91) class_decl -> CLASS IDENTIFIER COLON inheritance_list class_content .
    CLASS           reduce using rule 91 (class_decl -> CLASS IDENTIFIER COLON inheritance_list class_content .)
    TYPE_SPECIFIER  reduce using rule 91 (class_decl -> CLASS IDENTIFIER COLON inheritance_list class_content .)
    $end            reduce using rule 91 (class_decl -> CLASS IDENTIFIER COLON inheritance_list class_content .)


state 34

    (96) inheritance_list -> inheritance _6_COMMA_inheritance_optional .
    LEFT_BRACE      reduce using rule 96 (inheritance_list -> inheritance _6_COMMA_inheritance_optional .)


state 35

    (97) _6_COMMA_inheritance_optional -> COMMA . inheritance
    (99) inheritance -> . IDENTIFIER
    (100) inheritance -> . access_specifier IDENTIFIER
    (101) access_specifier -> . ACCESS_SPECIFIER
    IDENTIFIER      shift and go to state 19
    ACCESS_SPECIFIER shift and go to state 23

    inheritance                    shift and go to state 46
    access_specifier               shift and go to state 22

state 36

    (100) inheritance -> access_specifier IDENTIFIER .
    COMMA           reduce using rule 100 (inheritance -> access_specifier IDENTIFIER .)
    LEFT_BRACE      reduce using rule 100 (inheritance -> access_specifier IDENTIFIER .)


state 37

    (93) class_content -> LEFT_BRACE _5_members_decl_optional RIGHT_BRACE . SEMICOLON
    SEMICOLON       shift and go to state 47


state 38

    (102) members_decl -> access_specifier COLON . members_list
    (103) members_list -> . var_decl
    (104) members_list -> . func_decl
    (105) members_list -> . constructor_decl
    (106) members_list -> . destructor_decl
    (8) var_decl -> . type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (9) var_decl -> . type_spec IDENTIFIER SEMICOLON
    (10) func_decl -> . type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
    (107) constructor_decl -> . IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
    (108) destructor_decl -> . ~ IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_stmt
    (7) type_spec -> . TYPE_SPECIFIER
    IDENTIFIER      shift and go to state 54
    ~               shift and go to state 55
    TYPE_SPECIFIER  shift and go to state 9

    members_list                   shift and go to state 48
    var_decl                       shift and go to state 49
    func_decl                      shift and go to state 50
    constructor_decl               shift and go to state 51
    destructor_decl                shift and go to state 52
    type_spec                      shift and go to state 53

state 39

    (10) func_decl -> type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN . compound_stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    LEFT_BRACE      shift and go to state 57

    compound_stmt                  shift and go to state 56

state 40

    (13) param_list -> param _1_COMMA_param_repeat .
    RIGHT_PAREN     reduce using rule 13 (param_list -> param _1_COMMA_param_repeat .)


state 41

    (14) _1_COMMA_param_repeat -> _1_COMMA_param_items .
    (16) _1_COMMA_param_items -> _1_COMMA_param_items . _1_COMMA_param_item
    (18) _1_COMMA_param_item -> . COMMA param
    RIGHT_PAREN     reduce using rule 14 (_1_COMMA_param_repeat -> _1_COMMA_param_items .)
    COMMA           shift and go to state 43

    _1_COMMA_param_item            shift and go to state 58

state 42

    (17) _1_COMMA_param_items -> _1_COMMA_param_item .
    COMMA           reduce using rule 17 (_1_COMMA_param_items -> _1_COMMA_param_item .)
    RIGHT_PAREN     reduce using rule 17 (_1_COMMA_param_items -> _1_COMMA_param_item .)


state 43

    (18) _1_COMMA_param_item -> COMMA . param
    (19) param -> . TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET
    (20) param -> . TYPE_SPECIFIER IDENTIFIER
    TYPE_SPECIFIER  shift and go to state 31

    param                          shift and go to state 59

state 44

    (19) param -> TYPE_SPECIFIER IDENTIFIER . LEFT_BRACKET RIGHT_BRACKET
    (20) param -> TYPE_SPECIFIER IDENTIFIER .
    LEFT_BRACKET    shift and go to state 60
    COMMA           reduce using rule 20 (param -> TYPE_SPECIFIER IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 20 (param -> TYPE_SPECIFIER IDENTIFIER .)


state 45

    (8) var_decl -> type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .
    CLASS           reduce using rule 8 (var_decl -> type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    TYPE_SPECIFIER  reduce using rule 8 (var_decl -> type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    $end            reduce using rule 8 (var_decl -> type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    RIGHT_BRACE     reduce using rule 8 (var_decl -> type_spec IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)


state 46

    (97) _6_COMMA_inheritance_optional -> COMMA inheritance .
    LEFT_BRACE      reduce using rule 97 (_6_COMMA_inheritance_optional -> COMMA inheritance .)


state 47

    (93) class_content -> LEFT_BRACE _5_members_decl_optional RIGHT_BRACE SEMICOLON .
    CLASS           reduce using rule 93 (class_content -> LEFT_BRACE _5_members_decl_optional RIGHT_BRACE SEMICOLON .)
    TYPE_SPECIFIER  reduce using rule 93 (class_content -> LEFT_BRACE _5_members_decl_optional RIGHT_BRACE SEMICOLON .)
    $end            reduce using rule 93 (class_content -> LEFT_BRACE _5_members_decl_optional RIGHT_BRACE SEMICOLON .)


state 48

    (102) members_decl -> access_specifier COLON members_list .
    RIGHT_BRACE     reduce using rule 102 (members_decl -> access_specifier COLON members_list .)


state 49

    (103) members_list -> var_decl .
    RIGHT_BRACE     reduce using rule 103 (members_list -> var_decl .)


state 50

    (104) members_list -> func_decl .
    RIGHT_BRACE     reduce using rule 104 (members_list -> func_decl .)


state 51

    (105) members_list -> constructor_decl .
    RIGHT_BRACE     reduce using rule 105 (members_list -> constructor_decl .)


state 52

    (106) members_list -> destructor_decl .
    RIGHT_BRACE     reduce using rule 106 (members_list -> destructor_decl .)


state 53

    (8) var_decl -> type_spec . IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (9) var_decl -> type_spec . IDENTIFIER SEMICOLON
    (10) func_decl -> type_spec . IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt
    IDENTIFIER      shift and go to state 61


state 54

    (107) constructor_decl -> IDENTIFIER . LEFT_PAREN params RIGHT_PAREN compound_stmt
    LEFT_PAREN      shift and go to state 62


state 55

    (108) destructor_decl -> ~ . IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_stmt
    IDENTIFIER      shift and go to state 63


state 56

    (10) func_decl -> type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt .
    CLASS           reduce using rule 10 (func_decl -> type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt .)
    TYPE_SPECIFIER  reduce using rule 10 (func_decl -> type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt .)
    $end            reduce using rule 10 (func_decl -> type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt .)
    RIGHT_BRACE     reduce using rule 10 (func_decl -> type_spec IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt .)


state 57

    (21) compound_stmt -> LEFT_BRACE . local_decls stmt_list RIGHT_BRACE
    (22) local_decls -> . empty
    (23) local_decls -> . local_decl
    (109) empty -> .
    (24) local_decl -> . TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (25) local_decl -> . TYPE_SPECIFIER IDENTIFIER SEMICOLON
    SIZE            reduce using rule 109 (empty -> .)
    CONTINUE        reduce using rule 109 (empty -> .)
    BREAK           reduce using rule 109 (empty -> .)
    RETURN          reduce using rule 109 (empty -> .)
    WHILE           reduce using rule 109 (empty -> .)
    IF              reduce using rule 109 (empty -> .)
    LEFT_BRACE      reduce using rule 109 (empty -> .)
    SEMICOLON       reduce using rule 109 (empty -> .)
    NEW             reduce using rule 109 (empty -> .)
    STRING_LITERAL  reduce using rule 109 (empty -> .)
    FLOAT_LITERAL   reduce using rule 109 (empty -> .)
    INT_LITERAL     reduce using rule 109 (empty -> .)
    BOOL_LITERAL    reduce using rule 109 (empty -> .)
    IDENTIFIER      reduce using rule 109 (empty -> .)
    LEFT_PAREN      reduce using rule 109 (empty -> .)
    PLUS            reduce using rule 109 (empty -> .)
    MINUS           reduce using rule 109 (empty -> .)
    NOT             reduce using rule 109 (empty -> .)
    PRINTF          reduce using rule 109 (empty -> .)
    RIGHT_BRACE     reduce using rule 109 (empty -> .)
    TYPE_SPECIFIER  shift and go to state 67

    local_decls                    shift and go to state 64
    empty                          shift and go to state 65
    local_decl                     shift and go to state 66

state 58

    (16) _1_COMMA_param_items -> _1_COMMA_param_items _1_COMMA_param_item .
    COMMA           reduce using rule 16 (_1_COMMA_param_items -> _1_COMMA_param_items _1_COMMA_param_item .)
    RIGHT_PAREN     reduce using rule 16 (_1_COMMA_param_items -> _1_COMMA_param_items _1_COMMA_param_item .)


state 59

    (18) _1_COMMA_param_item -> COMMA param .
    COMMA           reduce using rule 18 (_1_COMMA_param_item -> COMMA param .)
    RIGHT_PAREN     reduce using rule 18 (_1_COMMA_param_item -> COMMA param .)


state 60

    (19) param -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET . RIGHT_BRACKET
    RIGHT_BRACKET   shift and go to state 68


state 61

    (8) var_decl -> type_spec IDENTIFIER . LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (9) var_decl -> type_spec IDENTIFIER . SEMICOLON
    (10) func_decl -> type_spec IDENTIFIER . LEFT_PAREN params RIGHT_PAREN compound_stmt
    LEFT_BRACKET    shift and go to state 17
    SEMICOLON       shift and go to state 18
    LEFT_PAREN      shift and go to state 16


state 62

    (107) constructor_decl -> IDENTIFIER LEFT_PAREN . params RIGHT_PAREN compound_stmt
    (11) params -> . empty
    (12) params -> . param_list
    (109) empty -> .
    (13) param_list -> . param _1_COMMA_param_repeat
    (19) param -> . TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET
    (20) param -> . TYPE_SPECIFIER IDENTIFIER
    RIGHT_PAREN     reduce using rule 109 (empty -> .)
    TYPE_SPECIFIER  shift and go to state 31

    params                         shift and go to state 69
    empty                          shift and go to state 28
    param_list                     shift and go to state 29
    param                          shift and go to state 30

state 63

    (108) destructor_decl -> ~ IDENTIFIER . LEFT_PAREN RIGHT_PAREN compound_stmt
    LEFT_PAREN      shift and go to state 70


state 64

    (21) compound_stmt -> LEFT_BRACE local_decls . stmt_list RIGHT_BRACE
    (26) stmt_list -> . _2_stmt_repeat
    (27) _2_stmt_repeat -> . _2_stmt_items
    (28) _2_stmt_repeat -> .
    (29) _2_stmt_items -> . _2_stmt_items _2_stmt_item
    (30) _2_stmt_items -> . _2_stmt_item
    (31) _2_stmt_item -> . stmt
    (32) stmt -> . size_stmt
    (33) stmt -> . continue_stmt
    (34) stmt -> . break_stmt
    (35) stmt -> . return_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (56) size_stmt -> . SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
    (55) continue_stmt -> . CONTINUE SEMICOLON
    (47) break_stmt -> . BREAK SEMICOLON
    (45) return_stmt -> . RETURN expr SEMICOLON
    (46) return_stmt -> . RETURN SEMICOLON
    (44) while_stmt -> . WHILE LEFT_PAREN expr RIGHT_PAREN stmt
    (42) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (43) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    (40) expr_stmt -> . SEMICOLON
    (41) expr_stmt -> . expr SEMICOLON
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    RIGHT_BRACE     reduce using rule 28 (_2_stmt_repeat -> .)
    SIZE            shift and go to state 84
    CONTINUE        shift and go to state 88
    BREAK           shift and go to state 89
    RETURN          shift and go to state 90
    WHILE           shift and go to state 91
    IF              shift and go to state 92
    LEFT_BRACE      shift and go to state 57
    SEMICOLON       shift and go to state 87
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    stmt_list                      shift and go to state 71
    _2_stmt_repeat                 shift and go to state 72
    _2_stmt_items                  shift and go to state 73
    _2_stmt_item                   shift and go to state 74
    stmt                           shift and go to state 75
    size_stmt                      shift and go to state 76
    continue_stmt                  shift and go to state 77
    break_stmt                     shift and go to state 78
    return_stmt                    shift and go to state 79
    while_stmt                     shift and go to state 80
    if_stmt                        shift and go to state 81
    compound_stmt                  shift and go to state 82
    expr_stmt                      shift and go to state 83
    expr                           shift and go to state 86
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 65

    (22) local_decls -> empty .
    SIZE            reduce using rule 22 (local_decls -> empty .)
    CONTINUE        reduce using rule 22 (local_decls -> empty .)
    BREAK           reduce using rule 22 (local_decls -> empty .)
    RETURN          reduce using rule 22 (local_decls -> empty .)
    WHILE           reduce using rule 22 (local_decls -> empty .)
    IF              reduce using rule 22 (local_decls -> empty .)
    LEFT_BRACE      reduce using rule 22 (local_decls -> empty .)
    SEMICOLON       reduce using rule 22 (local_decls -> empty .)
    NEW             reduce using rule 22 (local_decls -> empty .)
    STRING_LITERAL  reduce using rule 22 (local_decls -> empty .)
    FLOAT_LITERAL   reduce using rule 22 (local_decls -> empty .)
    INT_LITERAL     reduce using rule 22 (local_decls -> empty .)
    BOOL_LITERAL    reduce using rule 22 (local_decls -> empty .)
    IDENTIFIER      reduce using rule 22 (local_decls -> empty .)
    LEFT_PAREN      reduce using rule 22 (local_decls -> empty .)
    PLUS            reduce using rule 22 (local_decls -> empty .)
    MINUS           reduce using rule 22 (local_decls -> empty .)
    NOT             reduce using rule 22 (local_decls -> empty .)
    PRINTF          reduce using rule 22 (local_decls -> empty .)
    RIGHT_BRACE     reduce using rule 22 (local_decls -> empty .)


state 66

    (23) local_decls -> local_decl .
    SIZE            reduce using rule 23 (local_decls -> local_decl .)
    CONTINUE        reduce using rule 23 (local_decls -> local_decl .)
    BREAK           reduce using rule 23 (local_decls -> local_decl .)
    RETURN          reduce using rule 23 (local_decls -> local_decl .)
    WHILE           reduce using rule 23 (local_decls -> local_decl .)
    IF              reduce using rule 23 (local_decls -> local_decl .)
    LEFT_BRACE      reduce using rule 23 (local_decls -> local_decl .)
    SEMICOLON       reduce using rule 23 (local_decls -> local_decl .)
    NEW             reduce using rule 23 (local_decls -> local_decl .)
    STRING_LITERAL  reduce using rule 23 (local_decls -> local_decl .)
    FLOAT_LITERAL   reduce using rule 23 (local_decls -> local_decl .)
    INT_LITERAL     reduce using rule 23 (local_decls -> local_decl .)
    BOOL_LITERAL    reduce using rule 23 (local_decls -> local_decl .)
    IDENTIFIER      reduce using rule 23 (local_decls -> local_decl .)
    LEFT_PAREN      reduce using rule 23 (local_decls -> local_decl .)
    PLUS            reduce using rule 23 (local_decls -> local_decl .)
    MINUS           reduce using rule 23 (local_decls -> local_decl .)
    NOT             reduce using rule 23 (local_decls -> local_decl .)
    PRINTF          reduce using rule 23 (local_decls -> local_decl .)
    RIGHT_BRACE     reduce using rule 23 (local_decls -> local_decl .)


state 67

    (24) local_decl -> TYPE_SPECIFIER . IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (25) local_decl -> TYPE_SPECIFIER . IDENTIFIER SEMICOLON
    IDENTIFIER      shift and go to state 105


state 68

    (19) param -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET .
    COMMA           reduce using rule 19 (param -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 19 (param -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET .)


state 69

    (107) constructor_decl -> IDENTIFIER LEFT_PAREN params . RIGHT_PAREN compound_stmt
    RIGHT_PAREN     shift and go to state 106


state 70

    (108) destructor_decl -> ~ IDENTIFIER LEFT_PAREN . RIGHT_PAREN compound_stmt
    RIGHT_PAREN     shift and go to state 107


state 71

    (21) compound_stmt -> LEFT_BRACE local_decls stmt_list . RIGHT_BRACE
    RIGHT_BRACE     shift and go to state 108


state 72

    (26) stmt_list -> _2_stmt_repeat .
    RIGHT_BRACE     reduce using rule 26 (stmt_list -> _2_stmt_repeat .)


state 73

    (27) _2_stmt_repeat -> _2_stmt_items .
    (29) _2_stmt_items -> _2_stmt_items . _2_stmt_item
    (31) _2_stmt_item -> . stmt
    (32) stmt -> . size_stmt
    (33) stmt -> . continue_stmt
    (34) stmt -> . break_stmt
    (35) stmt -> . return_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (56) size_stmt -> . SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
    (55) continue_stmt -> . CONTINUE SEMICOLON
    (47) break_stmt -> . BREAK SEMICOLON
    (45) return_stmt -> . RETURN expr SEMICOLON
    (46) return_stmt -> . RETURN SEMICOLON
    (44) while_stmt -> . WHILE LEFT_PAREN expr RIGHT_PAREN stmt
    (42) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (43) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    (40) expr_stmt -> . SEMICOLON
    (41) expr_stmt -> . expr SEMICOLON
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    RIGHT_BRACE     reduce using rule 27 (_2_stmt_repeat -> _2_stmt_items .)
    SIZE            shift and go to state 84
    CONTINUE        shift and go to state 88
    BREAK           shift and go to state 89
    RETURN          shift and go to state 90
    WHILE           shift and go to state 91
    IF              shift and go to state 92
    LEFT_BRACE      shift and go to state 57
    SEMICOLON       shift and go to state 87
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    _2_stmt_item                   shift and go to state 109
    stmt                           shift and go to state 75
    size_stmt                      shift and go to state 76
    continue_stmt                  shift and go to state 77
    break_stmt                     shift and go to state 78
    return_stmt                    shift and go to state 79
    while_stmt                     shift and go to state 80
    if_stmt                        shift and go to state 81
    compound_stmt                  shift and go to state 82
    expr_stmt                      shift and go to state 83
    expr                           shift and go to state 86
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 74

    (30) _2_stmt_items -> _2_stmt_item .
    SIZE            reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    CONTINUE        reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    BREAK           reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    RETURN          reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    WHILE           reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    IF              reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    LEFT_BRACE      reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    SEMICOLON       reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    NEW             reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    STRING_LITERAL  reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    FLOAT_LITERAL   reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    INT_LITERAL     reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    BOOL_LITERAL    reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    IDENTIFIER      reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    LEFT_PAREN      reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    PLUS            reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    MINUS           reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    NOT             reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    PRINTF          reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)
    RIGHT_BRACE     reduce using rule 30 (_2_stmt_items -> _2_stmt_item .)


state 75

    (31) _2_stmt_item -> stmt .
    SIZE            reduce using rule 31 (_2_stmt_item -> stmt .)
    CONTINUE        reduce using rule 31 (_2_stmt_item -> stmt .)
    BREAK           reduce using rule 31 (_2_stmt_item -> stmt .)
    RETURN          reduce using rule 31 (_2_stmt_item -> stmt .)
    WHILE           reduce using rule 31 (_2_stmt_item -> stmt .)
    IF              reduce using rule 31 (_2_stmt_item -> stmt .)
    LEFT_BRACE      reduce using rule 31 (_2_stmt_item -> stmt .)
    SEMICOLON       reduce using rule 31 (_2_stmt_item -> stmt .)
    NEW             reduce using rule 31 (_2_stmt_item -> stmt .)
    STRING_LITERAL  reduce using rule 31 (_2_stmt_item -> stmt .)
    FLOAT_LITERAL   reduce using rule 31 (_2_stmt_item -> stmt .)
    INT_LITERAL     reduce using rule 31 (_2_stmt_item -> stmt .)
    BOOL_LITERAL    reduce using rule 31 (_2_stmt_item -> stmt .)
    IDENTIFIER      reduce using rule 31 (_2_stmt_item -> stmt .)
    LEFT_PAREN      reduce using rule 31 (_2_stmt_item -> stmt .)
    PLUS            reduce using rule 31 (_2_stmt_item -> stmt .)
    MINUS           reduce using rule 31 (_2_stmt_item -> stmt .)
    NOT             reduce using rule 31 (_2_stmt_item -> stmt .)
    PRINTF          reduce using rule 31 (_2_stmt_item -> stmt .)
    RIGHT_BRACE     reduce using rule 31 (_2_stmt_item -> stmt .)


state 76

    (32) stmt -> size_stmt .
    SIZE            reduce using rule 32 (stmt -> size_stmt .)
    CONTINUE        reduce using rule 32 (stmt -> size_stmt .)
    BREAK           reduce using rule 32 (stmt -> size_stmt .)
    RETURN          reduce using rule 32 (stmt -> size_stmt .)
    WHILE           reduce using rule 32 (stmt -> size_stmt .)
    IF              reduce using rule 32 (stmt -> size_stmt .)
    LEFT_BRACE      reduce using rule 32 (stmt -> size_stmt .)
    SEMICOLON       reduce using rule 32 (stmt -> size_stmt .)
    NEW             reduce using rule 32 (stmt -> size_stmt .)
    STRING_LITERAL  reduce using rule 32 (stmt -> size_stmt .)
    FLOAT_LITERAL   reduce using rule 32 (stmt -> size_stmt .)
    INT_LITERAL     reduce using rule 32 (stmt -> size_stmt .)
    BOOL_LITERAL    reduce using rule 32 (stmt -> size_stmt .)
    IDENTIFIER      reduce using rule 32 (stmt -> size_stmt .)
    LEFT_PAREN      reduce using rule 32 (stmt -> size_stmt .)
    PLUS            reduce using rule 32 (stmt -> size_stmt .)
    MINUS           reduce using rule 32 (stmt -> size_stmt .)
    NOT             reduce using rule 32 (stmt -> size_stmt .)
    PRINTF          reduce using rule 32 (stmt -> size_stmt .)
    RIGHT_BRACE     reduce using rule 32 (stmt -> size_stmt .)
    ELSE            reduce using rule 32 (stmt -> size_stmt .)


state 77

    (33) stmt -> continue_stmt .
    SIZE            reduce using rule 33 (stmt -> continue_stmt .)
    CONTINUE        reduce using rule 33 (stmt -> continue_stmt .)
    BREAK           reduce using rule 33 (stmt -> continue_stmt .)
    RETURN          reduce using rule 33 (stmt -> continue_stmt .)
    WHILE           reduce using rule 33 (stmt -> continue_stmt .)
    IF              reduce using rule 33 (stmt -> continue_stmt .)
    LEFT_BRACE      reduce using rule 33 (stmt -> continue_stmt .)
    SEMICOLON       reduce using rule 33 (stmt -> continue_stmt .)
    NEW             reduce using rule 33 (stmt -> continue_stmt .)
    STRING_LITERAL  reduce using rule 33 (stmt -> continue_stmt .)
    FLOAT_LITERAL   reduce using rule 33 (stmt -> continue_stmt .)
    INT_LITERAL     reduce using rule 33 (stmt -> continue_stmt .)
    BOOL_LITERAL    reduce using rule 33 (stmt -> continue_stmt .)
    IDENTIFIER      reduce using rule 33 (stmt -> continue_stmt .)
    LEFT_PAREN      reduce using rule 33 (stmt -> continue_stmt .)
    PLUS            reduce using rule 33 (stmt -> continue_stmt .)
    MINUS           reduce using rule 33 (stmt -> continue_stmt .)
    NOT             reduce using rule 33 (stmt -> continue_stmt .)
    PRINTF          reduce using rule 33 (stmt -> continue_stmt .)
    RIGHT_BRACE     reduce using rule 33 (stmt -> continue_stmt .)
    ELSE            reduce using rule 33 (stmt -> continue_stmt .)


state 78

    (34) stmt -> break_stmt .
    SIZE            reduce using rule 34 (stmt -> break_stmt .)
    CONTINUE        reduce using rule 34 (stmt -> break_stmt .)
    BREAK           reduce using rule 34 (stmt -> break_stmt .)
    RETURN          reduce using rule 34 (stmt -> break_stmt .)
    WHILE           reduce using rule 34 (stmt -> break_stmt .)
    IF              reduce using rule 34 (stmt -> break_stmt .)
    LEFT_BRACE      reduce using rule 34 (stmt -> break_stmt .)
    SEMICOLON       reduce using rule 34 (stmt -> break_stmt .)
    NEW             reduce using rule 34 (stmt -> break_stmt .)
    STRING_LITERAL  reduce using rule 34 (stmt -> break_stmt .)
    FLOAT_LITERAL   reduce using rule 34 (stmt -> break_stmt .)
    INT_LITERAL     reduce using rule 34 (stmt -> break_stmt .)
    BOOL_LITERAL    reduce using rule 34 (stmt -> break_stmt .)
    IDENTIFIER      reduce using rule 34 (stmt -> break_stmt .)
    LEFT_PAREN      reduce using rule 34 (stmt -> break_stmt .)
    PLUS            reduce using rule 34 (stmt -> break_stmt .)
    MINUS           reduce using rule 34 (stmt -> break_stmt .)
    NOT             reduce using rule 34 (stmt -> break_stmt .)
    PRINTF          reduce using rule 34 (stmt -> break_stmt .)
    RIGHT_BRACE     reduce using rule 34 (stmt -> break_stmt .)
    ELSE            reduce using rule 34 (stmt -> break_stmt .)


state 79

    (35) stmt -> return_stmt .
    SIZE            reduce using rule 35 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 35 (stmt -> return_stmt .)
    BREAK           reduce using rule 35 (stmt -> return_stmt .)
    RETURN          reduce using rule 35 (stmt -> return_stmt .)
    WHILE           reduce using rule 35 (stmt -> return_stmt .)
    IF              reduce using rule 35 (stmt -> return_stmt .)
    LEFT_BRACE      reduce using rule 35 (stmt -> return_stmt .)
    SEMICOLON       reduce using rule 35 (stmt -> return_stmt .)
    NEW             reduce using rule 35 (stmt -> return_stmt .)
    STRING_LITERAL  reduce using rule 35 (stmt -> return_stmt .)
    FLOAT_LITERAL   reduce using rule 35 (stmt -> return_stmt .)
    INT_LITERAL     reduce using rule 35 (stmt -> return_stmt .)
    BOOL_LITERAL    reduce using rule 35 (stmt -> return_stmt .)
    IDENTIFIER      reduce using rule 35 (stmt -> return_stmt .)
    LEFT_PAREN      reduce using rule 35 (stmt -> return_stmt .)
    PLUS            reduce using rule 35 (stmt -> return_stmt .)
    MINUS           reduce using rule 35 (stmt -> return_stmt .)
    NOT             reduce using rule 35 (stmt -> return_stmt .)
    PRINTF          reduce using rule 35 (stmt -> return_stmt .)
    RIGHT_BRACE     reduce using rule 35 (stmt -> return_stmt .)
    ELSE            reduce using rule 35 (stmt -> return_stmt .)


state 80

    (36) stmt -> while_stmt .
    SIZE            reduce using rule 36 (stmt -> while_stmt .)
    CONTINUE        reduce using rule 36 (stmt -> while_stmt .)
    BREAK           reduce using rule 36 (stmt -> while_stmt .)
    RETURN          reduce using rule 36 (stmt -> while_stmt .)
    WHILE           reduce using rule 36 (stmt -> while_stmt .)
    IF              reduce using rule 36 (stmt -> while_stmt .)
    LEFT_BRACE      reduce using rule 36 (stmt -> while_stmt .)
    SEMICOLON       reduce using rule 36 (stmt -> while_stmt .)
    NEW             reduce using rule 36 (stmt -> while_stmt .)
    STRING_LITERAL  reduce using rule 36 (stmt -> while_stmt .)
    FLOAT_LITERAL   reduce using rule 36 (stmt -> while_stmt .)
    INT_LITERAL     reduce using rule 36 (stmt -> while_stmt .)
    BOOL_LITERAL    reduce using rule 36 (stmt -> while_stmt .)
    IDENTIFIER      reduce using rule 36 (stmt -> while_stmt .)
    LEFT_PAREN      reduce using rule 36 (stmt -> while_stmt .)
    PLUS            reduce using rule 36 (stmt -> while_stmt .)
    MINUS           reduce using rule 36 (stmt -> while_stmt .)
    NOT             reduce using rule 36 (stmt -> while_stmt .)
    PRINTF          reduce using rule 36 (stmt -> while_stmt .)
    RIGHT_BRACE     reduce using rule 36 (stmt -> while_stmt .)
    ELSE            reduce using rule 36 (stmt -> while_stmt .)


state 81

    (37) stmt -> if_stmt .
    SIZE            reduce using rule 37 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 37 (stmt -> if_stmt .)
    BREAK           reduce using rule 37 (stmt -> if_stmt .)
    RETURN          reduce using rule 37 (stmt -> if_stmt .)
    WHILE           reduce using rule 37 (stmt -> if_stmt .)
    IF              reduce using rule 37 (stmt -> if_stmt .)
    LEFT_BRACE      reduce using rule 37 (stmt -> if_stmt .)
    SEMICOLON       reduce using rule 37 (stmt -> if_stmt .)
    NEW             reduce using rule 37 (stmt -> if_stmt .)
    STRING_LITERAL  reduce using rule 37 (stmt -> if_stmt .)
    FLOAT_LITERAL   reduce using rule 37 (stmt -> if_stmt .)
    INT_LITERAL     reduce using rule 37 (stmt -> if_stmt .)
    BOOL_LITERAL    reduce using rule 37 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 37 (stmt -> if_stmt .)
    LEFT_PAREN      reduce using rule 37 (stmt -> if_stmt .)
    PLUS            reduce using rule 37 (stmt -> if_stmt .)
    MINUS           reduce using rule 37 (stmt -> if_stmt .)
    NOT             reduce using rule 37 (stmt -> if_stmt .)
    PRINTF          reduce using rule 37 (stmt -> if_stmt .)
    RIGHT_BRACE     reduce using rule 37 (stmt -> if_stmt .)
    ELSE            reduce using rule 37 (stmt -> if_stmt .)


state 82

    (38) stmt -> compound_stmt .
    SIZE            reduce using rule 38 (stmt -> compound_stmt .)
    CONTINUE        reduce using rule 38 (stmt -> compound_stmt .)
    BREAK           reduce using rule 38 (stmt -> compound_stmt .)
    RETURN          reduce using rule 38 (stmt -> compound_stmt .)
    WHILE           reduce using rule 38 (stmt -> compound_stmt .)
    IF              reduce using rule 38 (stmt -> compound_stmt .)
    LEFT_BRACE      reduce using rule 38 (stmt -> compound_stmt .)
    SEMICOLON       reduce using rule 38 (stmt -> compound_stmt .)
    NEW             reduce using rule 38 (stmt -> compound_stmt .)
    STRING_LITERAL  reduce using rule 38 (stmt -> compound_stmt .)
    FLOAT_LITERAL   reduce using rule 38 (stmt -> compound_stmt .)
    INT_LITERAL     reduce using rule 38 (stmt -> compound_stmt .)
    BOOL_LITERAL    reduce using rule 38 (stmt -> compound_stmt .)
    IDENTIFIER      reduce using rule 38 (stmt -> compound_stmt .)
    LEFT_PAREN      reduce using rule 38 (stmt -> compound_stmt .)
    PLUS            reduce using rule 38 (stmt -> compound_stmt .)
    MINUS           reduce using rule 38 (stmt -> compound_stmt .)
    NOT             reduce using rule 38 (stmt -> compound_stmt .)
    PRINTF          reduce using rule 38 (stmt -> compound_stmt .)
    RIGHT_BRACE     reduce using rule 38 (stmt -> compound_stmt .)
    ELSE            reduce using rule 38 (stmt -> compound_stmt .)


state 83

    (39) stmt -> expr_stmt .
    SIZE            reduce using rule 39 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 39 (stmt -> expr_stmt .)
    BREAK           reduce using rule 39 (stmt -> expr_stmt .)
    RETURN          reduce using rule 39 (stmt -> expr_stmt .)
    WHILE           reduce using rule 39 (stmt -> expr_stmt .)
    IF              reduce using rule 39 (stmt -> expr_stmt .)
    LEFT_BRACE      reduce using rule 39 (stmt -> expr_stmt .)
    SEMICOLON       reduce using rule 39 (stmt -> expr_stmt .)
    NEW             reduce using rule 39 (stmt -> expr_stmt .)
    STRING_LITERAL  reduce using rule 39 (stmt -> expr_stmt .)
    FLOAT_LITERAL   reduce using rule 39 (stmt -> expr_stmt .)
    INT_LITERAL     reduce using rule 39 (stmt -> expr_stmt .)
    BOOL_LITERAL    reduce using rule 39 (stmt -> expr_stmt .)
    IDENTIFIER      reduce using rule 39 (stmt -> expr_stmt .)
    LEFT_PAREN      reduce using rule 39 (stmt -> expr_stmt .)
    PLUS            reduce using rule 39 (stmt -> expr_stmt .)
    MINUS           reduce using rule 39 (stmt -> expr_stmt .)
    NOT             reduce using rule 39 (stmt -> expr_stmt .)
    PRINTF          reduce using rule 39 (stmt -> expr_stmt .)
    RIGHT_BRACE     reduce using rule 39 (stmt -> expr_stmt .)
    ELSE            reduce using rule 39 (stmt -> expr_stmt .)


state 84

    (56) size_stmt -> SIZE . LEFT_PAREN expr RIGHT_PAREN SEMICOLON
    LEFT_PAREN      shift and go to state 110


state 85

    (67) expr -> LEFT_PAREN . expr RIGHT_PAREN
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 111
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 86

    (41) expr_stmt -> expr . SEMICOLON
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       shift and go to state 112
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 87

    (40) expr_stmt -> SEMICOLON .
    SIZE            reduce using rule 40 (expr_stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 40 (expr_stmt -> SEMICOLON .)
    BREAK           reduce using rule 40 (expr_stmt -> SEMICOLON .)
    RETURN          reduce using rule 40 (expr_stmt -> SEMICOLON .)
    WHILE           reduce using rule 40 (expr_stmt -> SEMICOLON .)
    IF              reduce using rule 40 (expr_stmt -> SEMICOLON .)
    LEFT_BRACE      reduce using rule 40 (expr_stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 40 (expr_stmt -> SEMICOLON .)
    NEW             reduce using rule 40 (expr_stmt -> SEMICOLON .)
    STRING_LITERAL  reduce using rule 40 (expr_stmt -> SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 40 (expr_stmt -> SEMICOLON .)
    INT_LITERAL     reduce using rule 40 (expr_stmt -> SEMICOLON .)
    BOOL_LITERAL    reduce using rule 40 (expr_stmt -> SEMICOLON .)
    IDENTIFIER      reduce using rule 40 (expr_stmt -> SEMICOLON .)
    LEFT_PAREN      reduce using rule 40 (expr_stmt -> SEMICOLON .)
    PLUS            reduce using rule 40 (expr_stmt -> SEMICOLON .)
    MINUS           reduce using rule 40 (expr_stmt -> SEMICOLON .)
    NOT             reduce using rule 40 (expr_stmt -> SEMICOLON .)
    PRINTF          reduce using rule 40 (expr_stmt -> SEMICOLON .)
    RIGHT_BRACE     reduce using rule 40 (expr_stmt -> SEMICOLON .)
    ELSE            reduce using rule 40 (expr_stmt -> SEMICOLON .)


state 88

    (55) continue_stmt -> CONTINUE . SEMICOLON
    SEMICOLON       shift and go to state 126


state 89

    (47) break_stmt -> BREAK . SEMICOLON
    SEMICOLON       shift and go to state 127


state 90

    (45) return_stmt -> RETURN . expr SEMICOLON
    (46) return_stmt -> RETURN . SEMICOLON
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    SEMICOLON       shift and go to state 129
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 128
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 91

    (44) while_stmt -> WHILE . LEFT_PAREN expr RIGHT_PAREN stmt
    LEFT_PAREN      shift and go to state 130


state 92

    (42) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (43) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 131


state 93

    (57) expr -> printf_call .
    SEMICOLON       reduce using rule 57 (expr -> printf_call .)
    MOD             reduce using rule 57 (expr -> printf_call .)
    DIVIDE          reduce using rule 57 (expr -> printf_call .)
    TIMES           reduce using rule 57 (expr -> printf_call .)
    MINUS           reduce using rule 57 (expr -> printf_call .)
    PLUS            reduce using rule 57 (expr -> printf_call .)
    GREATER_EQUAL   reduce using rule 57 (expr -> printf_call .)
    GREATER         reduce using rule 57 (expr -> printf_call .)
    LESS_EQUAL      reduce using rule 57 (expr -> printf_call .)
    LESS            reduce using rule 57 (expr -> printf_call .)
    NOT_EQUAL       reduce using rule 57 (expr -> printf_call .)
    EQUAL           reduce using rule 57 (expr -> printf_call .)
    AND             reduce using rule 57 (expr -> printf_call .)
    OR              reduce using rule 57 (expr -> printf_call .)
    RIGHT_PAREN     reduce using rule 57 (expr -> printf_call .)
    )               reduce using rule 57 (expr -> printf_call .)
    COMMA           reduce using rule 57 (expr -> printf_call .)
    RIGHT_BRACKET   reduce using rule 57 (expr -> printf_call .)


state 94

    (58) expr -> NEW . TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    TYPE_SPECIFIER  shift and go to state 132


state 95

    (59) expr -> STRING_LITERAL .
    SEMICOLON       reduce using rule 59 (expr -> STRING_LITERAL .)
    MOD             reduce using rule 59 (expr -> STRING_LITERAL .)
    DIVIDE          reduce using rule 59 (expr -> STRING_LITERAL .)
    TIMES           reduce using rule 59 (expr -> STRING_LITERAL .)
    MINUS           reduce using rule 59 (expr -> STRING_LITERAL .)
    PLUS            reduce using rule 59 (expr -> STRING_LITERAL .)
    GREATER_EQUAL   reduce using rule 59 (expr -> STRING_LITERAL .)
    GREATER         reduce using rule 59 (expr -> STRING_LITERAL .)
    LESS_EQUAL      reduce using rule 59 (expr -> STRING_LITERAL .)
    LESS            reduce using rule 59 (expr -> STRING_LITERAL .)
    NOT_EQUAL       reduce using rule 59 (expr -> STRING_LITERAL .)
    EQUAL           reduce using rule 59 (expr -> STRING_LITERAL .)
    AND             reduce using rule 59 (expr -> STRING_LITERAL .)
    OR              reduce using rule 59 (expr -> STRING_LITERAL .)
    RIGHT_PAREN     reduce using rule 59 (expr -> STRING_LITERAL .)
    )               reduce using rule 59 (expr -> STRING_LITERAL .)
    COMMA           reduce using rule 59 (expr -> STRING_LITERAL .)
    RIGHT_BRACKET   reduce using rule 59 (expr -> STRING_LITERAL .)


state 96

    (60) expr -> FLOAT_LITERAL .
    SEMICOLON       reduce using rule 60 (expr -> FLOAT_LITERAL .)
    MOD             reduce using rule 60 (expr -> FLOAT_LITERAL .)
    DIVIDE          reduce using rule 60 (expr -> FLOAT_LITERAL .)
    TIMES           reduce using rule 60 (expr -> FLOAT_LITERAL .)
    MINUS           reduce using rule 60 (expr -> FLOAT_LITERAL .)
    PLUS            reduce using rule 60 (expr -> FLOAT_LITERAL .)
    GREATER_EQUAL   reduce using rule 60 (expr -> FLOAT_LITERAL .)
    GREATER         reduce using rule 60 (expr -> FLOAT_LITERAL .)
    LESS_EQUAL      reduce using rule 60 (expr -> FLOAT_LITERAL .)
    LESS            reduce using rule 60 (expr -> FLOAT_LITERAL .)
    NOT_EQUAL       reduce using rule 60 (expr -> FLOAT_LITERAL .)
    EQUAL           reduce using rule 60 (expr -> FLOAT_LITERAL .)
    AND             reduce using rule 60 (expr -> FLOAT_LITERAL .)
    OR              reduce using rule 60 (expr -> FLOAT_LITERAL .)
    RIGHT_PAREN     reduce using rule 60 (expr -> FLOAT_LITERAL .)
    )               reduce using rule 60 (expr -> FLOAT_LITERAL .)
    COMMA           reduce using rule 60 (expr -> FLOAT_LITERAL .)
    RIGHT_BRACKET   reduce using rule 60 (expr -> FLOAT_LITERAL .)


state 97

    (61) expr -> INT_LITERAL .
    SEMICOLON       reduce using rule 61 (expr -> INT_LITERAL .)
    MOD             reduce using rule 61 (expr -> INT_LITERAL .)
    DIVIDE          reduce using rule 61 (expr -> INT_LITERAL .)
    TIMES           reduce using rule 61 (expr -> INT_LITERAL .)
    MINUS           reduce using rule 61 (expr -> INT_LITERAL .)
    PLUS            reduce using rule 61 (expr -> INT_LITERAL .)
    GREATER_EQUAL   reduce using rule 61 (expr -> INT_LITERAL .)
    GREATER         reduce using rule 61 (expr -> INT_LITERAL .)
    LESS_EQUAL      reduce using rule 61 (expr -> INT_LITERAL .)
    LESS            reduce using rule 61 (expr -> INT_LITERAL .)
    NOT_EQUAL       reduce using rule 61 (expr -> INT_LITERAL .)
    EQUAL           reduce using rule 61 (expr -> INT_LITERAL .)
    AND             reduce using rule 61 (expr -> INT_LITERAL .)
    OR              reduce using rule 61 (expr -> INT_LITERAL .)
    RIGHT_PAREN     reduce using rule 61 (expr -> INT_LITERAL .)
    )               reduce using rule 61 (expr -> INT_LITERAL .)
    COMMA           reduce using rule 61 (expr -> INT_LITERAL .)
    RIGHT_BRACKET   reduce using rule 61 (expr -> INT_LITERAL .)


state 98

    (62) expr -> BOOL_LITERAL .
    SEMICOLON       reduce using rule 62 (expr -> BOOL_LITERAL .)
    MOD             reduce using rule 62 (expr -> BOOL_LITERAL .)
    DIVIDE          reduce using rule 62 (expr -> BOOL_LITERAL .)
    TIMES           reduce using rule 62 (expr -> BOOL_LITERAL .)
    MINUS           reduce using rule 62 (expr -> BOOL_LITERAL .)
    PLUS            reduce using rule 62 (expr -> BOOL_LITERAL .)
    GREATER_EQUAL   reduce using rule 62 (expr -> BOOL_LITERAL .)
    GREATER         reduce using rule 62 (expr -> BOOL_LITERAL .)
    LESS_EQUAL      reduce using rule 62 (expr -> BOOL_LITERAL .)
    LESS            reduce using rule 62 (expr -> BOOL_LITERAL .)
    NOT_EQUAL       reduce using rule 62 (expr -> BOOL_LITERAL .)
    EQUAL           reduce using rule 62 (expr -> BOOL_LITERAL .)
    AND             reduce using rule 62 (expr -> BOOL_LITERAL .)
    OR              reduce using rule 62 (expr -> BOOL_LITERAL .)
    RIGHT_PAREN     reduce using rule 62 (expr -> BOOL_LITERAL .)
    )               reduce using rule 62 (expr -> BOOL_LITERAL .)
    COMMA           reduce using rule 62 (expr -> BOOL_LITERAL .)
    RIGHT_BRACKET   reduce using rule 62 (expr -> BOOL_LITERAL .)


state 99

    (63) expr -> IDENTIFIER . DOT SIZE
    (64) expr -> IDENTIFIER . LEFT_PAREN args RIGHT_PAREN
    (65) expr -> IDENTIFIER . LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> IDENTIFIER .
    (84) expr -> IDENTIFIER . LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> IDENTIFIER . ASSIGN expr
    DOT             shift and go to state 133
    LEFT_PAREN      shift and go to state 134
    LEFT_BRACKET    shift and go to state 135
    SEMICOLON       reduce using rule 66 (expr -> IDENTIFIER .)
    MOD             reduce using rule 66 (expr -> IDENTIFIER .)
    DIVIDE          reduce using rule 66 (expr -> IDENTIFIER .)
    TIMES           reduce using rule 66 (expr -> IDENTIFIER .)
    MINUS           reduce using rule 66 (expr -> IDENTIFIER .)
    PLUS            reduce using rule 66 (expr -> IDENTIFIER .)
    GREATER_EQUAL   reduce using rule 66 (expr -> IDENTIFIER .)
    GREATER         reduce using rule 66 (expr -> IDENTIFIER .)
    LESS_EQUAL      reduce using rule 66 (expr -> IDENTIFIER .)
    LESS            reduce using rule 66 (expr -> IDENTIFIER .)
    NOT_EQUAL       reduce using rule 66 (expr -> IDENTIFIER .)
    EQUAL           reduce using rule 66 (expr -> IDENTIFIER .)
    AND             reduce using rule 66 (expr -> IDENTIFIER .)
    OR              reduce using rule 66 (expr -> IDENTIFIER .)
    RIGHT_PAREN     reduce using rule 66 (expr -> IDENTIFIER .)
    )               reduce using rule 66 (expr -> IDENTIFIER .)
    COMMA           reduce using rule 66 (expr -> IDENTIFIER .)
    RIGHT_BRACKET   reduce using rule 66 (expr -> IDENTIFIER .)
    ASSIGN          shift and go to state 136


state 100

    (68) expr -> PLUS . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 137
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 101

    (69) expr -> MINUS . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 138
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 102

    (70) expr -> NOT . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 139
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 103

    (54) printf_call -> printf_stmt .
    SEMICOLON       reduce using rule 54 (printf_call -> printf_stmt .)
    MOD             reduce using rule 54 (printf_call -> printf_stmt .)
    DIVIDE          reduce using rule 54 (printf_call -> printf_stmt .)
    TIMES           reduce using rule 54 (printf_call -> printf_stmt .)
    MINUS           reduce using rule 54 (printf_call -> printf_stmt .)
    PLUS            reduce using rule 54 (printf_call -> printf_stmt .)
    GREATER_EQUAL   reduce using rule 54 (printf_call -> printf_stmt .)
    GREATER         reduce using rule 54 (printf_call -> printf_stmt .)
    LESS_EQUAL      reduce using rule 54 (printf_call -> printf_stmt .)
    LESS            reduce using rule 54 (printf_call -> printf_stmt .)
    NOT_EQUAL       reduce using rule 54 (printf_call -> printf_stmt .)
    EQUAL           reduce using rule 54 (printf_call -> printf_stmt .)
    AND             reduce using rule 54 (printf_call -> printf_stmt .)
    OR              reduce using rule 54 (printf_call -> printf_stmt .)
    RIGHT_PAREN     reduce using rule 54 (printf_call -> printf_stmt .)
    )               reduce using rule 54 (printf_call -> printf_stmt .)
    COMMA           reduce using rule 54 (printf_call -> printf_stmt .)
    RIGHT_BRACKET   reduce using rule 54 (printf_call -> printf_stmt .)


state 104

    (48) printf_stmt -> PRINTF . LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    LEFT_PAREN      shift and go to state 140


state 105

    (24) local_decl -> TYPE_SPECIFIER IDENTIFIER . LEFT_BRACKET RIGHT_BRACKET SEMICOLON
    (25) local_decl -> TYPE_SPECIFIER IDENTIFIER . SEMICOLON
    LEFT_BRACKET    shift and go to state 141
    SEMICOLON       shift and go to state 142


state 106

    (107) constructor_decl -> IDENTIFIER LEFT_PAREN params RIGHT_PAREN . compound_stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    LEFT_BRACE      shift and go to state 57

    compound_stmt                  shift and go to state 143

state 107

    (108) destructor_decl -> ~ IDENTIFIER LEFT_PAREN RIGHT_PAREN . compound_stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    LEFT_BRACE      shift and go to state 57

    compound_stmt                  shift and go to state 144

state 108

    (21) compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .
    CLASS           reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    TYPE_SPECIFIER  reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    $end            reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    RIGHT_BRACE     reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    SIZE            reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    CONTINUE        reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    BREAK           reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    RETURN          reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    WHILE           reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    IF              reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    LEFT_BRACE      reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    SEMICOLON       reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    NEW             reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    STRING_LITERAL  reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    FLOAT_LITERAL   reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    INT_LITERAL     reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    BOOL_LITERAL    reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    IDENTIFIER      reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    LEFT_PAREN      reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    PLUS            reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    MINUS           reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    NOT             reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    PRINTF          reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)
    ELSE            reduce using rule 21 (compound_stmt -> LEFT_BRACE local_decls stmt_list RIGHT_BRACE .)


state 109

    (29) _2_stmt_items -> _2_stmt_items _2_stmt_item .
    SIZE            reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    CONTINUE        reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    BREAK           reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    RETURN          reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    WHILE           reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    IF              reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    LEFT_BRACE      reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    SEMICOLON       reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    NEW             reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    STRING_LITERAL  reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    FLOAT_LITERAL   reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    INT_LITERAL     reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    BOOL_LITERAL    reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    IDENTIFIER      reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    LEFT_PAREN      reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    PLUS            reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    MINUS           reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    NOT             reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    PRINTF          reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)
    RIGHT_BRACE     reduce using rule 29 (_2_stmt_items -> _2_stmt_items _2_stmt_item .)


state 110

    (56) size_stmt -> SIZE LEFT_PAREN . expr RIGHT_PAREN SEMICOLON
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 145
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 111

    (67) expr -> LEFT_PAREN expr . RIGHT_PAREN
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    RIGHT_PAREN     shift and go to state 146
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 112

    (41) expr_stmt -> expr SEMICOLON .
    SIZE            reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    CONTINUE        reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    BREAK           reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    WHILE           reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    IF              reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    LEFT_BRACE      reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    NEW             reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    STRING_LITERAL  reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    INT_LITERAL     reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    BOOL_LITERAL    reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    IDENTIFIER      reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    LEFT_PAREN      reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    PLUS            reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    NOT             reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    PRINTF          reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    RIGHT_BRACE     reduce using rule 41 (expr_stmt -> expr SEMICOLON .)
    ELSE            reduce using rule 41 (expr_stmt -> expr SEMICOLON .)


state 113

    (71) expr -> expr MOD . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 147
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 114

    (72) expr -> expr DIVIDE . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 148
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 115

    (73) expr -> expr TIMES . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 149
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 116

    (74) expr -> expr MINUS . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 150
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 117

    (75) expr -> expr PLUS . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 151
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 118

    (76) expr -> expr GREATER_EQUAL . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 152
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 119

    (77) expr -> expr GREATER . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 153
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 120

    (78) expr -> expr LESS_EQUAL . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 154
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 121

    (79) expr -> expr LESS . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 155
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 122

    (80) expr -> expr NOT_EQUAL . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 156
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 123

    (81) expr -> expr EQUAL . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 157
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 124

    (82) expr -> expr AND . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 158
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 125

    (83) expr -> expr OR . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 159
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 126

    (55) continue_stmt -> CONTINUE SEMICOLON .
    SIZE            reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    LEFT_BRACE      reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    STRING_LITERAL  reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    INT_LITERAL     reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    BOOL_LITERAL    reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    LEFT_PAREN      reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    PLUS            reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    MINUS           reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    PRINTF          reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    RIGHT_BRACE     reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 55 (continue_stmt -> CONTINUE SEMICOLON .)


state 127

    (47) break_stmt -> BREAK SEMICOLON .
    SIZE            reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    LEFT_BRACE      reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    STRING_LITERAL  reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    INT_LITERAL     reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    BOOL_LITERAL    reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    LEFT_PAREN      reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    PLUS            reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    MINUS           reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    NOT             reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    PRINTF          reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    RIGHT_BRACE     reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 47 (break_stmt -> BREAK SEMICOLON .)


state 128

    (45) return_stmt -> RETURN expr . SEMICOLON
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       shift and go to state 160
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 129

    (46) return_stmt -> RETURN SEMICOLON .
    SIZE            reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    LEFT_BRACE      reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    STRING_LITERAL  reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    INT_LITERAL     reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    BOOL_LITERAL    reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    LEFT_PAREN      reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    PLUS            reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    MINUS           reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    NOT             reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    PRINTF          reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 46 (return_stmt -> RETURN SEMICOLON .)


state 130

    (44) while_stmt -> WHILE LEFT_PAREN . expr RIGHT_PAREN stmt
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 161
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 131

    (42) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (43) if_stmt -> IF ( . expr ) stmt
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 162
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 132

    (58) expr -> NEW TYPE_SPECIFIER . LEFT_BRACKET expr RIGHT_BRACKET
    LEFT_BRACKET    shift and go to state 163


state 133

    (63) expr -> IDENTIFIER DOT . SIZE
    SIZE            shift and go to state 164


state 134

    (64) expr -> IDENTIFIER LEFT_PAREN . args RIGHT_PAREN
    (86) args -> . empty
    (87) args -> . arg_list
    (109) empty -> .
    (88) arg_list -> . expr _4_COMMA_expr_optional
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    RIGHT_PAREN     reduce using rule 109 (empty -> .)
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    args                           shift and go to state 165
    empty                          shift and go to state 166
    arg_list                       shift and go to state 167
    expr                           shift and go to state 168
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 135

    (65) expr -> IDENTIFIER LEFT_BRACKET . expr RIGHT_BRACKET
    (84) expr -> IDENTIFIER LEFT_BRACKET . expr RIGHT_BRACKET ASSIGN expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 169
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 136

    (85) expr -> IDENTIFIER ASSIGN . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 170
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 137

    (68) expr -> PLUS expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 68 (expr -> PLUS expr .)
    MOD             reduce using rule 68 (expr -> PLUS expr .)
    DIVIDE          reduce using rule 68 (expr -> PLUS expr .)
    TIMES           reduce using rule 68 (expr -> PLUS expr .)
    MINUS           reduce using rule 68 (expr -> PLUS expr .)
    PLUS            reduce using rule 68 (expr -> PLUS expr .)
    GREATER_EQUAL   reduce using rule 68 (expr -> PLUS expr .)
    GREATER         reduce using rule 68 (expr -> PLUS expr .)
    LESS_EQUAL      reduce using rule 68 (expr -> PLUS expr .)
    LESS            reduce using rule 68 (expr -> PLUS expr .)
    NOT_EQUAL       reduce using rule 68 (expr -> PLUS expr .)
    EQUAL           reduce using rule 68 (expr -> PLUS expr .)
    AND             reduce using rule 68 (expr -> PLUS expr .)
    OR              reduce using rule 68 (expr -> PLUS expr .)
    RIGHT_PAREN     reduce using rule 68 (expr -> PLUS expr .)
    )               reduce using rule 68 (expr -> PLUS expr .)
    COMMA           reduce using rule 68 (expr -> PLUS expr .)
    RIGHT_BRACKET   reduce using rule 68 (expr -> PLUS expr .)


state 138

    (69) expr -> MINUS expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 69 (expr -> MINUS expr .)
    MOD             reduce using rule 69 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 69 (expr -> MINUS expr .)
    TIMES           reduce using rule 69 (expr -> MINUS expr .)
    MINUS           reduce using rule 69 (expr -> MINUS expr .)
    PLUS            reduce using rule 69 (expr -> MINUS expr .)
    GREATER_EQUAL   reduce using rule 69 (expr -> MINUS expr .)
    GREATER         reduce using rule 69 (expr -> MINUS expr .)
    LESS_EQUAL      reduce using rule 69 (expr -> MINUS expr .)
    LESS            reduce using rule 69 (expr -> MINUS expr .)
    NOT_EQUAL       reduce using rule 69 (expr -> MINUS expr .)
    EQUAL           reduce using rule 69 (expr -> MINUS expr .)
    AND             reduce using rule 69 (expr -> MINUS expr .)
    OR              reduce using rule 69 (expr -> MINUS expr .)
    RIGHT_PAREN     reduce using rule 69 (expr -> MINUS expr .)
    )               reduce using rule 69 (expr -> MINUS expr .)
    COMMA           reduce using rule 69 (expr -> MINUS expr .)
    RIGHT_BRACKET   reduce using rule 69 (expr -> MINUS expr .)


state 139

    (70) expr -> NOT expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 70 (expr -> NOT expr .)
    MOD             reduce using rule 70 (expr -> NOT expr .)
    DIVIDE          reduce using rule 70 (expr -> NOT expr .)
    TIMES           reduce using rule 70 (expr -> NOT expr .)
    MINUS           reduce using rule 70 (expr -> NOT expr .)
    PLUS            reduce using rule 70 (expr -> NOT expr .)
    GREATER_EQUAL   reduce using rule 70 (expr -> NOT expr .)
    GREATER         reduce using rule 70 (expr -> NOT expr .)
    LESS_EQUAL      reduce using rule 70 (expr -> NOT expr .)
    LESS            reduce using rule 70 (expr -> NOT expr .)
    NOT_EQUAL       reduce using rule 70 (expr -> NOT expr .)
    EQUAL           reduce using rule 70 (expr -> NOT expr .)
    AND             reduce using rule 70 (expr -> NOT expr .)
    OR              reduce using rule 70 (expr -> NOT expr .)
    RIGHT_PAREN     reduce using rule 70 (expr -> NOT expr .)
    )               reduce using rule 70 (expr -> NOT expr .)
    COMMA           reduce using rule 70 (expr -> NOT expr .)
    RIGHT_BRACKET   reduce using rule 70 (expr -> NOT expr .)


state 140

    (48) printf_stmt -> PRINTF LEFT_PAREN . STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    STRING_LITERAL  shift and go to state 171


state 141

    (24) local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET . RIGHT_BRACKET SEMICOLON
    RIGHT_BRACKET   shift and go to state 172


state 142

    (25) local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .
    SIZE            reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    CONTINUE        reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    BREAK           reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    IF              reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    LEFT_BRACE      reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    NEW             reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    STRING_LITERAL  reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    INT_LITERAL     reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    BOOL_LITERAL    reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    LEFT_PAREN      reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    PLUS            reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    PRINTF          reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)
    RIGHT_BRACE     reduce using rule 25 (local_decl -> TYPE_SPECIFIER IDENTIFIER SEMICOLON .)


state 143

    (107) constructor_decl -> IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt .
    RIGHT_BRACE     reduce using rule 107 (constructor_decl -> IDENTIFIER LEFT_PAREN params RIGHT_PAREN compound_stmt .)


state 144

    (108) destructor_decl -> ~ IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_stmt .
    RIGHT_BRACE     reduce using rule 108 (destructor_decl -> ~ IDENTIFIER LEFT_PAREN RIGHT_PAREN compound_stmt .)


state 145

    (56) size_stmt -> SIZE LEFT_PAREN expr . RIGHT_PAREN SEMICOLON
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    RIGHT_PAREN     shift and go to state 173
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 146

    (67) expr -> LEFT_PAREN expr RIGHT_PAREN .
    SEMICOLON       reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    MOD             reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    DIVIDE          reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    TIMES           reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    MINUS           reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    PLUS            reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    GREATER         reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    LESS            reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    NOT_EQUAL       reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    EQUAL           reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    AND             reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    OR              reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    )               reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    COMMA           reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 67 (expr -> LEFT_PAREN expr RIGHT_PAREN .)


state 147

    (71) expr -> expr MOD expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 71 (expr -> expr MOD expr .)
    MOD             reduce using rule 71 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 71 (expr -> expr MOD expr .)
    TIMES           reduce using rule 71 (expr -> expr MOD expr .)
    MINUS           reduce using rule 71 (expr -> expr MOD expr .)
    PLUS            reduce using rule 71 (expr -> expr MOD expr .)
    GREATER_EQUAL   reduce using rule 71 (expr -> expr MOD expr .)
    GREATER         reduce using rule 71 (expr -> expr MOD expr .)
    LESS_EQUAL      reduce using rule 71 (expr -> expr MOD expr .)
    LESS            reduce using rule 71 (expr -> expr MOD expr .)
    NOT_EQUAL       reduce using rule 71 (expr -> expr MOD expr .)
    EQUAL           reduce using rule 71 (expr -> expr MOD expr .)
    AND             reduce using rule 71 (expr -> expr MOD expr .)
    OR              reduce using rule 71 (expr -> expr MOD expr .)
    RIGHT_PAREN     reduce using rule 71 (expr -> expr MOD expr .)
    )               reduce using rule 71 (expr -> expr MOD expr .)
    COMMA           reduce using rule 71 (expr -> expr MOD expr .)
    RIGHT_BRACKET   reduce using rule 71 (expr -> expr MOD expr .)


state 148

    (72) expr -> expr DIVIDE expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 72 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 72 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 72 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 72 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 72 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 72 (expr -> expr DIVIDE expr .)
    GREATER_EQUAL   reduce using rule 72 (expr -> expr DIVIDE expr .)
    GREATER         reduce using rule 72 (expr -> expr DIVIDE expr .)
    LESS_EQUAL      reduce using rule 72 (expr -> expr DIVIDE expr .)
    LESS            reduce using rule 72 (expr -> expr DIVIDE expr .)
    NOT_EQUAL       reduce using rule 72 (expr -> expr DIVIDE expr .)
    EQUAL           reduce using rule 72 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 72 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 72 (expr -> expr DIVIDE expr .)
    RIGHT_PAREN     reduce using rule 72 (expr -> expr DIVIDE expr .)
    )               reduce using rule 72 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 72 (expr -> expr DIVIDE expr .)
    RIGHT_BRACKET   reduce using rule 72 (expr -> expr DIVIDE expr .)


state 149

    (73) expr -> expr TIMES expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 73 (expr -> expr TIMES expr .)
    MOD             reduce using rule 73 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 73 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 73 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 73 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 73 (expr -> expr TIMES expr .)
    GREATER_EQUAL   reduce using rule 73 (expr -> expr TIMES expr .)
    GREATER         reduce using rule 73 (expr -> expr TIMES expr .)
    LESS_EQUAL      reduce using rule 73 (expr -> expr TIMES expr .)
    LESS            reduce using rule 73 (expr -> expr TIMES expr .)
    NOT_EQUAL       reduce using rule 73 (expr -> expr TIMES expr .)
    EQUAL           reduce using rule 73 (expr -> expr TIMES expr .)
    AND             reduce using rule 73 (expr -> expr TIMES expr .)
    OR              reduce using rule 73 (expr -> expr TIMES expr .)
    RIGHT_PAREN     reduce using rule 73 (expr -> expr TIMES expr .)
    )               reduce using rule 73 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 73 (expr -> expr TIMES expr .)
    RIGHT_BRACKET   reduce using rule 73 (expr -> expr TIMES expr .)


state 150

    (74) expr -> expr MINUS expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 74 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 74 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 74 (expr -> expr MINUS expr .)
    GREATER_EQUAL   reduce using rule 74 (expr -> expr MINUS expr .)
    GREATER         reduce using rule 74 (expr -> expr MINUS expr .)
    LESS_EQUAL      reduce using rule 74 (expr -> expr MINUS expr .)
    LESS            reduce using rule 74 (expr -> expr MINUS expr .)
    NOT_EQUAL       reduce using rule 74 (expr -> expr MINUS expr .)
    EQUAL           reduce using rule 74 (expr -> expr MINUS expr .)
    AND             reduce using rule 74 (expr -> expr MINUS expr .)
    OR              reduce using rule 74 (expr -> expr MINUS expr .)
    RIGHT_PAREN     reduce using rule 74 (expr -> expr MINUS expr .)
    )               reduce using rule 74 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 74 (expr -> expr MINUS expr .)
    RIGHT_BRACKET   reduce using rule 74 (expr -> expr MINUS expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115


state 151

    (75) expr -> expr PLUS expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 75 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 75 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 75 (expr -> expr PLUS expr .)
    GREATER_EQUAL   reduce using rule 75 (expr -> expr PLUS expr .)
    GREATER         reduce using rule 75 (expr -> expr PLUS expr .)
    LESS_EQUAL      reduce using rule 75 (expr -> expr PLUS expr .)
    LESS            reduce using rule 75 (expr -> expr PLUS expr .)
    NOT_EQUAL       reduce using rule 75 (expr -> expr PLUS expr .)
    EQUAL           reduce using rule 75 (expr -> expr PLUS expr .)
    AND             reduce using rule 75 (expr -> expr PLUS expr .)
    OR              reduce using rule 75 (expr -> expr PLUS expr .)
    RIGHT_PAREN     reduce using rule 75 (expr -> expr PLUS expr .)
    )               reduce using rule 75 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 75 (expr -> expr PLUS expr .)
    RIGHT_BRACKET   reduce using rule 75 (expr -> expr PLUS expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115


state 152

    (76) expr -> expr GREATER_EQUAL expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    GREATER         reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    LESS_EQUAL      reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    LESS            reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    NOT_EQUAL       reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    EQUAL           reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    AND             reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    OR              reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    RIGHT_PAREN     reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    )               reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    COMMA           reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    RIGHT_BRACKET   reduce using rule 76 (expr -> expr GREATER_EQUAL expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117


state 153

    (77) expr -> expr GREATER expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 77 (expr -> expr GREATER expr .)
    GREATER_EQUAL   reduce using rule 77 (expr -> expr GREATER expr .)
    GREATER         reduce using rule 77 (expr -> expr GREATER expr .)
    LESS_EQUAL      reduce using rule 77 (expr -> expr GREATER expr .)
    LESS            reduce using rule 77 (expr -> expr GREATER expr .)
    NOT_EQUAL       reduce using rule 77 (expr -> expr GREATER expr .)
    EQUAL           reduce using rule 77 (expr -> expr GREATER expr .)
    AND             reduce using rule 77 (expr -> expr GREATER expr .)
    OR              reduce using rule 77 (expr -> expr GREATER expr .)
    RIGHT_PAREN     reduce using rule 77 (expr -> expr GREATER expr .)
    )               reduce using rule 77 (expr -> expr GREATER expr .)
    COMMA           reduce using rule 77 (expr -> expr GREATER expr .)
    RIGHT_BRACKET   reduce using rule 77 (expr -> expr GREATER expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117


state 154

    (78) expr -> expr LESS_EQUAL expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    GREATER_EQUAL   reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    GREATER         reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    LESS_EQUAL      reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    LESS            reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    NOT_EQUAL       reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    EQUAL           reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    AND             reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    OR              reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    RIGHT_PAREN     reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    )               reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    COMMA           reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    RIGHT_BRACKET   reduce using rule 78 (expr -> expr LESS_EQUAL expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117


state 155

    (79) expr -> expr LESS expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 79 (expr -> expr LESS expr .)
    GREATER_EQUAL   reduce using rule 79 (expr -> expr LESS expr .)
    GREATER         reduce using rule 79 (expr -> expr LESS expr .)
    LESS_EQUAL      reduce using rule 79 (expr -> expr LESS expr .)
    LESS            reduce using rule 79 (expr -> expr LESS expr .)
    NOT_EQUAL       reduce using rule 79 (expr -> expr LESS expr .)
    EQUAL           reduce using rule 79 (expr -> expr LESS expr .)
    AND             reduce using rule 79 (expr -> expr LESS expr .)
    OR              reduce using rule 79 (expr -> expr LESS expr .)
    RIGHT_PAREN     reduce using rule 79 (expr -> expr LESS expr .)
    )               reduce using rule 79 (expr -> expr LESS expr .)
    COMMA           reduce using rule 79 (expr -> expr LESS expr .)
    RIGHT_BRACKET   reduce using rule 79 (expr -> expr LESS expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117


state 156

    (80) expr -> expr NOT_EQUAL expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    NOT_EQUAL       reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    EQUAL           reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    AND             reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    OR              reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    RIGHT_PAREN     reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    )               reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    COMMA           reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    RIGHT_BRACKET   reduce using rule 80 (expr -> expr NOT_EQUAL expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121


state 157

    (81) expr -> expr EQUAL expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 81 (expr -> expr EQUAL expr .)
    NOT_EQUAL       reduce using rule 81 (expr -> expr EQUAL expr .)
    EQUAL           reduce using rule 81 (expr -> expr EQUAL expr .)
    AND             reduce using rule 81 (expr -> expr EQUAL expr .)
    OR              reduce using rule 81 (expr -> expr EQUAL expr .)
    RIGHT_PAREN     reduce using rule 81 (expr -> expr EQUAL expr .)
    )               reduce using rule 81 (expr -> expr EQUAL expr .)
    COMMA           reduce using rule 81 (expr -> expr EQUAL expr .)
    RIGHT_BRACKET   reduce using rule 81 (expr -> expr EQUAL expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121


state 158

    (82) expr -> expr AND expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 82 (expr -> expr AND expr .)
    AND             reduce using rule 82 (expr -> expr AND expr .)
    OR              reduce using rule 82 (expr -> expr AND expr .)
    RIGHT_PAREN     reduce using rule 82 (expr -> expr AND expr .)
    )               reduce using rule 82 (expr -> expr AND expr .)
    COMMA           reduce using rule 82 (expr -> expr AND expr .)
    RIGHT_BRACKET   reduce using rule 82 (expr -> expr AND expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123


state 159

    (83) expr -> expr OR expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 83 (expr -> expr OR expr .)
    OR              reduce using rule 83 (expr -> expr OR expr .)
    RIGHT_PAREN     reduce using rule 83 (expr -> expr OR expr .)
    )               reduce using rule 83 (expr -> expr OR expr .)
    COMMA           reduce using rule 83 (expr -> expr OR expr .)
    RIGHT_BRACKET   reduce using rule 83 (expr -> expr OR expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124


state 160

    (45) return_stmt -> RETURN expr SEMICOLON .
    SIZE            reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    LEFT_BRACE      reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    NEW             reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    STRING_LITERAL  reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    INT_LITERAL     reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    BOOL_LITERAL    reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    LEFT_PAREN      reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    PLUS            reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    PRINTF          reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    RIGHT_BRACE     reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 45 (return_stmt -> RETURN expr SEMICOLON .)


state 161

    (44) while_stmt -> WHILE LEFT_PAREN expr . RIGHT_PAREN stmt
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    RIGHT_PAREN     shift and go to state 174
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 162

    (42) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (43) if_stmt -> IF ( expr . ) stmt
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    )               shift and go to state 175
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 163

    (58) expr -> NEW TYPE_SPECIFIER LEFT_BRACKET . expr RIGHT_BRACKET
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 176
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 164

    (63) expr -> IDENTIFIER DOT SIZE .
    SEMICOLON       reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    MOD             reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    DIVIDE          reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    TIMES           reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    MINUS           reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    PLUS            reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    GREATER_EQUAL   reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    GREATER         reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    LESS_EQUAL      reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    LESS            reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    NOT_EQUAL       reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    EQUAL           reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    AND             reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    OR              reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    RIGHT_PAREN     reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    )               reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    COMMA           reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)
    RIGHT_BRACKET   reduce using rule 63 (expr -> IDENTIFIER DOT SIZE .)


state 165

    (64) expr -> IDENTIFIER LEFT_PAREN args . RIGHT_PAREN
    RIGHT_PAREN     shift and go to state 177


state 166

    (86) args -> empty .
    RIGHT_PAREN     reduce using rule 86 (args -> empty .)


state 167

    (87) args -> arg_list .
    RIGHT_PAREN     reduce using rule 87 (args -> arg_list .)


state 168

    (88) arg_list -> expr . _4_COMMA_expr_optional
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    (89) _4_COMMA_expr_optional -> . COMMA expr
    (90) _4_COMMA_expr_optional -> .
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125
    COMMA           shift and go to state 179
    RIGHT_PAREN     reduce using rule 90 (_4_COMMA_expr_optional -> .)

    _4_COMMA_expr_optional         shift and go to state 178

state 169

    (65) expr -> IDENTIFIER LEFT_BRACKET expr . RIGHT_BRACKET
    (84) expr -> IDENTIFIER LEFT_BRACKET expr . RIGHT_BRACKET ASSIGN expr
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    RIGHT_BRACKET   shift and go to state 180
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 170

    (85) expr -> IDENTIFIER ASSIGN expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 85 (expr -> IDENTIFIER ASSIGN expr .)
    RIGHT_PAREN     reduce using rule 85 (expr -> IDENTIFIER ASSIGN expr .)
    )               reduce using rule 85 (expr -> IDENTIFIER ASSIGN expr .)
    COMMA           reduce using rule 85 (expr -> IDENTIFIER ASSIGN expr .)
    RIGHT_BRACKET   reduce using rule 85 (expr -> IDENTIFIER ASSIGN expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 171

    (48) printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL . _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    (49) _3_COMMA_expr_repeat -> . _3_COMMA_expr_items
    (50) _3_COMMA_expr_repeat -> .
    (51) _3_COMMA_expr_items -> . _3_COMMA_expr_items _3_COMMA_expr_item
    (52) _3_COMMA_expr_items -> . _3_COMMA_expr_item
    (53) _3_COMMA_expr_item -> . COMMA expr
    RIGHT_PAREN     reduce using rule 50 (_3_COMMA_expr_repeat -> .)
    COMMA           shift and go to state 184

    _3_COMMA_expr_repeat           shift and go to state 181
    _3_COMMA_expr_items            shift and go to state 182
    _3_COMMA_expr_item             shift and go to state 183

state 172

    (24) local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET . SEMICOLON
    SEMICOLON       shift and go to state 185


state 173

    (56) size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN . SEMICOLON
    SEMICOLON       shift and go to state 186


state 174

    (44) while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN . stmt
    (32) stmt -> . size_stmt
    (33) stmt -> . continue_stmt
    (34) stmt -> . break_stmt
    (35) stmt -> . return_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (56) size_stmt -> . SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
    (55) continue_stmt -> . CONTINUE SEMICOLON
    (47) break_stmt -> . BREAK SEMICOLON
    (45) return_stmt -> . RETURN expr SEMICOLON
    (46) return_stmt -> . RETURN SEMICOLON
    (44) while_stmt -> . WHILE LEFT_PAREN expr RIGHT_PAREN stmt
    (42) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (43) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    (40) expr_stmt -> . SEMICOLON
    (41) expr_stmt -> . expr SEMICOLON
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    SIZE            shift and go to state 84
    CONTINUE        shift and go to state 88
    BREAK           shift and go to state 89
    RETURN          shift and go to state 90
    WHILE           shift and go to state 91
    IF              shift and go to state 92
    LEFT_BRACE      shift and go to state 57
    SEMICOLON       shift and go to state 87
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 86
    stmt                           shift and go to state 187
    size_stmt                      shift and go to state 76
    continue_stmt                  shift and go to state 77
    break_stmt                     shift and go to state 78
    return_stmt                    shift and go to state 79
    while_stmt                     shift and go to state 80
    if_stmt                        shift and go to state 81
    compound_stmt                  shift and go to state 82
    expr_stmt                      shift and go to state 83
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 175

    (42) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (43) if_stmt -> IF ( expr ) . stmt
    (32) stmt -> . size_stmt
    (33) stmt -> . continue_stmt
    (34) stmt -> . break_stmt
    (35) stmt -> . return_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (56) size_stmt -> . SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
    (55) continue_stmt -> . CONTINUE SEMICOLON
    (47) break_stmt -> . BREAK SEMICOLON
    (45) return_stmt -> . RETURN expr SEMICOLON
    (46) return_stmt -> . RETURN SEMICOLON
    (44) while_stmt -> . WHILE LEFT_PAREN expr RIGHT_PAREN stmt
    (42) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (43) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    (40) expr_stmt -> . SEMICOLON
    (41) expr_stmt -> . expr SEMICOLON
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    SIZE            shift and go to state 84
    CONTINUE        shift and go to state 88
    BREAK           shift and go to state 89
    RETURN          shift and go to state 90
    WHILE           shift and go to state 91
    IF              shift and go to state 92
    LEFT_BRACE      shift and go to state 57
    SEMICOLON       shift and go to state 87
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 86
    stmt                           shift and go to state 188
    size_stmt                      shift and go to state 76
    continue_stmt                  shift and go to state 77
    break_stmt                     shift and go to state 78
    return_stmt                    shift and go to state 79
    while_stmt                     shift and go to state 80
    if_stmt                        shift and go to state 81
    compound_stmt                  shift and go to state 82
    expr_stmt                      shift and go to state 83
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 176

    (58) expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr . RIGHT_BRACKET
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    RIGHT_BRACKET   shift and go to state 189
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 177

    (64) expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .
    SEMICOLON       reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    MOD             reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    DIVIDE          reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    TIMES           reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    MINUS           reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    PLUS            reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    GREATER_EQUAL   reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    GREATER         reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    LESS_EQUAL      reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    LESS            reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    NOT_EQUAL       reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    EQUAL           reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    AND             reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    OR              reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    RIGHT_PAREN     reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    )               reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    COMMA           reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)
    RIGHT_BRACKET   reduce using rule 64 (expr -> IDENTIFIER LEFT_PAREN args RIGHT_PAREN .)


state 178

    (88) arg_list -> expr _4_COMMA_expr_optional .
    RIGHT_PAREN     reduce using rule 88 (arg_list -> expr _4_COMMA_expr_optional .)


state 179

    (89) _4_COMMA_expr_optional -> COMMA . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 190
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 180

    (65) expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .
    (84) expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET . ASSIGN expr
    SEMICOLON       reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    MOD             reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    DIVIDE          reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    TIMES           reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    MINUS           reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    PLUS            reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    GREATER_EQUAL   reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    GREATER         reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    LESS_EQUAL      reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    LESS            reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    NOT_EQUAL       reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    EQUAL           reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    AND             reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    OR              reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    )               reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    COMMA           reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 65 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    ASSIGN          shift and go to state 191


state 181

    (48) printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat . RIGHT_PAREN SEMICOLON
    RIGHT_PAREN     shift and go to state 192


state 182

    (49) _3_COMMA_expr_repeat -> _3_COMMA_expr_items .
    (51) _3_COMMA_expr_items -> _3_COMMA_expr_items . _3_COMMA_expr_item
    (53) _3_COMMA_expr_item -> . COMMA expr
    RIGHT_PAREN     reduce using rule 49 (_3_COMMA_expr_repeat -> _3_COMMA_expr_items .)
    COMMA           shift and go to state 184

    _3_COMMA_expr_item             shift and go to state 193

state 183

    (52) _3_COMMA_expr_items -> _3_COMMA_expr_item .
    COMMA           reduce using rule 52 (_3_COMMA_expr_items -> _3_COMMA_expr_item .)
    RIGHT_PAREN     reduce using rule 52 (_3_COMMA_expr_items -> _3_COMMA_expr_item .)


state 184

    (53) _3_COMMA_expr_item -> COMMA . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 194
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 185

    (24) local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .
    SIZE            reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    CONTINUE        reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    BREAK           reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    RETURN          reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    WHILE           reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    IF              reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    LEFT_BRACE      reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    SEMICOLON       reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    NEW             reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    STRING_LITERAL  reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    INT_LITERAL     reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    BOOL_LITERAL    reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    IDENTIFIER      reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    LEFT_PAREN      reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    PLUS            reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    MINUS           reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    NOT             reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    PRINTF          reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)
    RIGHT_BRACE     reduce using rule 24 (local_decl -> TYPE_SPECIFIER IDENTIFIER LEFT_BRACKET RIGHT_BRACKET SEMICOLON .)


state 186

    (56) size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .
    SIZE            reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    CONTINUE        reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    BREAK           reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    RETURN          reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    WHILE           reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    IF              reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    LEFT_BRACE      reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    SEMICOLON       reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    NEW             reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    STRING_LITERAL  reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    FLOAT_LITERAL   reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    INT_LITERAL     reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    BOOL_LITERAL    reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    IDENTIFIER      reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    LEFT_PAREN      reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    PLUS            reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    NOT             reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    PRINTF          reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACE     reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)
    ELSE            reduce using rule 56 (size_stmt -> SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON .)


state 187

    (44) while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .
    SIZE            reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    CONTINUE        reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    BREAK           reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    RETURN          reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    WHILE           reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    IF              reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    LEFT_BRACE      reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    SEMICOLON       reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    NEW             reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    STRING_LITERAL  reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    FLOAT_LITERAL   reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    INT_LITERAL     reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    BOOL_LITERAL    reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    IDENTIFIER      reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    LEFT_PAREN      reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    PLUS            reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    MINUS           reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    NOT             reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    PRINTF          reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    RIGHT_BRACE     reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)
    ELSE            reduce using rule 44 (while_stmt -> WHILE LEFT_PAREN expr RIGHT_PAREN stmt .)


state 188

    (42) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (43) if_stmt -> IF ( expr ) stmt .
    ELSE            shift and go to state 195
    SIZE            reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    LEFT_BRACE      reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    SEMICOLON       reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    NEW             reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    STRING_LITERAL  reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    FLOAT_LITERAL   reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    INT_LITERAL     reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    BOOL_LITERAL    reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    IDENTIFIER      reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    LEFT_PAREN      reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    PLUS            reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    MINUS           reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    NOT             reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    PRINTF          reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)
    RIGHT_BRACE     reduce using rule 43 (if_stmt -> IF ( expr ) stmt .)


state 189

    (58) expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .
    SEMICOLON       reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    MOD             reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    DIVIDE          reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    TIMES           reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    MINUS           reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    PLUS            reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    GREATER_EQUAL   reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    GREATER         reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    LESS_EQUAL      reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    LESS            reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    NOT_EQUAL       reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    EQUAL           reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    AND             reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    OR              reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_PAREN     reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    )               reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    COMMA           reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)
    RIGHT_BRACKET   reduce using rule 58 (expr -> NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET .)


state 190

    (89) _4_COMMA_expr_optional -> COMMA expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    RIGHT_PAREN     reduce using rule 89 (_4_COMMA_expr_optional -> COMMA expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 191

    (84) expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN . expr
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 196
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 192

    (48) printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN . SEMICOLON
    SEMICOLON       shift and go to state 197


state 193

    (51) _3_COMMA_expr_items -> _3_COMMA_expr_items _3_COMMA_expr_item .
    COMMA           reduce using rule 51 (_3_COMMA_expr_items -> _3_COMMA_expr_items _3_COMMA_expr_item .)
    RIGHT_PAREN     reduce using rule 51 (_3_COMMA_expr_items -> _3_COMMA_expr_items _3_COMMA_expr_item .)


state 194

    (53) _3_COMMA_expr_item -> COMMA expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    COMMA           reduce using rule 53 (_3_COMMA_expr_item -> COMMA expr .)
    RIGHT_PAREN     reduce using rule 53 (_3_COMMA_expr_item -> COMMA expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 195

    (42) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (32) stmt -> . size_stmt
    (33) stmt -> . continue_stmt
    (34) stmt -> . break_stmt
    (35) stmt -> . return_stmt
    (36) stmt -> . while_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . compound_stmt
    (39) stmt -> . expr_stmt
    (56) size_stmt -> . SIZE LEFT_PAREN expr RIGHT_PAREN SEMICOLON
    (55) continue_stmt -> . CONTINUE SEMICOLON
    (47) break_stmt -> . BREAK SEMICOLON
    (45) return_stmt -> . RETURN expr SEMICOLON
    (46) return_stmt -> . RETURN SEMICOLON
    (44) while_stmt -> . WHILE LEFT_PAREN expr RIGHT_PAREN stmt
    (42) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (43) if_stmt -> . IF ( expr ) stmt
    (21) compound_stmt -> . LEFT_BRACE local_decls stmt_list RIGHT_BRACE
    (40) expr_stmt -> . SEMICOLON
    (41) expr_stmt -> . expr SEMICOLON
    (57) expr -> . printf_call
    (58) expr -> . NEW TYPE_SPECIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (59) expr -> . STRING_LITERAL
    (60) expr -> . FLOAT_LITERAL
    (61) expr -> . INT_LITERAL
    (62) expr -> . BOOL_LITERAL
    (63) expr -> . IDENTIFIER DOT SIZE
    (64) expr -> . IDENTIFIER LEFT_PAREN args RIGHT_PAREN
    (65) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET
    (66) expr -> . IDENTIFIER
    (67) expr -> . LEFT_PAREN expr RIGHT_PAREN
    (68) expr -> . PLUS expr
    (69) expr -> . MINUS expr
    (70) expr -> . NOT expr
    (71) expr -> . expr MOD expr
    (72) expr -> . expr DIVIDE expr
    (73) expr -> . expr TIMES expr
    (74) expr -> . expr MINUS expr
    (75) expr -> . expr PLUS expr
    (76) expr -> . expr GREATER_EQUAL expr
    (77) expr -> . expr GREATER expr
    (78) expr -> . expr LESS_EQUAL expr
    (79) expr -> . expr LESS expr
    (80) expr -> . expr NOT_EQUAL expr
    (81) expr -> . expr EQUAL expr
    (82) expr -> . expr AND expr
    (83) expr -> . expr OR expr
    (84) expr -> . IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr
    (85) expr -> . IDENTIFIER ASSIGN expr
    (54) printf_call -> . printf_stmt
    (48) printf_stmt -> . PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON
    SIZE            shift and go to state 84
    CONTINUE        shift and go to state 88
    BREAK           shift and go to state 89
    RETURN          shift and go to state 90
    WHILE           shift and go to state 91
    IF              shift and go to state 92
    LEFT_BRACE      shift and go to state 57
    SEMICOLON       shift and go to state 87
    NEW             shift and go to state 94
    STRING_LITERAL  shift and go to state 95
    FLOAT_LITERAL   shift and go to state 96
    INT_LITERAL     shift and go to state 97
    BOOL_LITERAL    shift and go to state 98
    IDENTIFIER      shift and go to state 99
    LEFT_PAREN      shift and go to state 85
    PLUS            shift and go to state 100
    MINUS           shift and go to state 101
    NOT             shift and go to state 102
    PRINTF          shift and go to state 104

    expr                           shift and go to state 86
    stmt                           shift and go to state 198
    size_stmt                      shift and go to state 76
    continue_stmt                  shift and go to state 77
    break_stmt                     shift and go to state 78
    return_stmt                    shift and go to state 79
    while_stmt                     shift and go to state 80
    if_stmt                        shift and go to state 81
    compound_stmt                  shift and go to state 82
    expr_stmt                      shift and go to state 83
    printf_call                    shift and go to state 93
    printf_stmt                    shift and go to state 103

state 196

    (84) expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr .
    (71) expr -> expr . MOD expr
    (72) expr -> expr . DIVIDE expr
    (73) expr -> expr . TIMES expr
    (74) expr -> expr . MINUS expr
    (75) expr -> expr . PLUS expr
    (76) expr -> expr . GREATER_EQUAL expr
    (77) expr -> expr . GREATER expr
    (78) expr -> expr . LESS_EQUAL expr
    (79) expr -> expr . LESS expr
    (80) expr -> expr . NOT_EQUAL expr
    (81) expr -> expr . EQUAL expr
    (82) expr -> expr . AND expr
    (83) expr -> expr . OR expr
    SEMICOLON       reduce using rule 84 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr .)
    RIGHT_PAREN     reduce using rule 84 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr .)
    )               reduce using rule 84 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr .)
    COMMA           reduce using rule 84 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr .)
    RIGHT_BRACKET   reduce using rule 84 (expr -> IDENTIFIER LEFT_BRACKET expr RIGHT_BRACKET ASSIGN expr .)
    MOD             shift and go to state 113
    DIVIDE          shift and go to state 114
    TIMES           shift and go to state 115
    MINUS           shift and go to state 116
    PLUS            shift and go to state 117
    GREATER_EQUAL   shift and go to state 118
    GREATER         shift and go to state 119
    LESS_EQUAL      shift and go to state 120
    LESS            shift and go to state 121
    NOT_EQUAL       shift and go to state 122
    EQUAL           shift and go to state 123
    AND             shift and go to state 124
    OR              shift and go to state 125


state 197

    (48) printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .
    SEMICOLON       reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    MOD             reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    DIVIDE          reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    TIMES           reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    MINUS           reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    PLUS            reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    GREATER_EQUAL   reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    GREATER         reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    LESS_EQUAL      reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    LESS            reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    NOT_EQUAL       reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    EQUAL           reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    AND             reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    OR              reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    RIGHT_PAREN     reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    )               reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    COMMA           reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)
    RIGHT_BRACKET   reduce using rule 48 (printf_stmt -> PRINTF LEFT_PAREN STRING_LITERAL _3_COMMA_expr_repeat RIGHT_PAREN SEMICOLON .)


state 198

    (42) if_stmt -> IF ( expr ) stmt ELSE stmt .
    SIZE            reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    LEFT_BRACE      reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    SEMICOLON       reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NEW             reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_LITERAL  reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT_LITERAL   reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT_LITERAL     reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BOOL_LITERAL    reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENTIFIER      reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    LEFT_PAREN      reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PLUS            reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    MINUS           reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    NOT             reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    PRINTF          reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RIGHT_BRACE     reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 42 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
