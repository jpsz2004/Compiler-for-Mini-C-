# Compiler-for-Mini-C++
This project wants to make a compiler for the programming language C++, but not all the concepts about it, but some basic and fundamental subjetcs of the language.

# Folder

About the 'Analizadores' folder, it can tell that it's contains the different classes we need to build the compiler. 

## Lexer
 The lexical parser is responsible for identifying the tokens that make up the C++ language.
* The sly library is used for the lexical parser implementation.
* The rich library is used for printing the identified tokens.
* Unit tests of test_cases.py are imported to print tokens.

Previously, Lexer was builded. The lexer, lets tokenize an input (test case) writen in C++ code. That works perfect.


## Parser
The parser is responsible for creating rules for tokens that make up the C++ language.
* The sly library is used for the implementation of the parser.
* The rich library is used for printing the identified tokens.
* The list of tokens from the CppLexer.py file is imported to work with them.

----> The shift/reduce problem in Mini-C++ grammar is solved for different reasons


>To solve the shift/reduce problem, the precedence of tokens is modified. 
To handle the IF, ELSE statement, the shift/reduce conflict occurs because the parser does not know if 
must shrink an if without else or move the else when it finds it in the input. 
With the solution proposed, by giving greater precedence to the else, the parser will always choose to move 
the else and associate it with the nearest if, eliminating the shift/reduce conflict.

>[!NOTE]
   >
   >Parser only needs be modified to recognize correctly the class constructors, the arrays declaration and one line comments.
## Checker
The semantic parser is responsible for verifying that the code the rules of the programming language, that is, the variables are declared before they are used, which
the data types are correct, that the functions are declared before use, etc.  

To do this, the AST generated by the parser is run and
They check the semantic rules of language. 


The checker is so important for this compiler. With it, we can check:

1. Build the Symbols table (you can use ChainMap).
2. Validate that any Identifier must be declared beforehand.
3. Add a cast instruction.
4. Validate that any expression must have type compatibility.
5. Validate that there is a main function (gateway).
6. Implement the iread, fread (scanf) function
7. Implement the FOR instruction.
8. Validate that the BREAK and CONTINUE instructions are used within WHILE/FOR instructions.

## Interpreter
The interpreter executes the code and evaluates its behavior by traversing the AST.
Key points about the interpreter:

* It interacts with the AST and the symbol table to execute the input program.
* Supports execution for Mini-C++ constructs like loops, conditionals, and basic operations.

# Test
There is a file called test.mcc. You can write on it a code example written using C++. Also, with this version you can add more files with any name
that contains C++ code.
For this version, there are nine files with test you can test with the next command (change the file for the file you want):

```
python Cpp.py -R Pruebas/test.mcc
```

## Execution
Using the program 'Cpp.py' the test are executed. On this program there are information about the AST, about de symbol table and about the lexer and tokens.
Next, there is some more of help to run the program Cpp.py, the compiler for Mini C++.

This file contains the entry point for executing the Mini-C++ compiler. It supports various operations such as token display, AST visualization, symbol table dumping, and program execution.

# Help?

usage: Cpp.py [-h] [-d] [-o OUT] [-l] [-a] [-D] [-p] [-I] [--sym] [-S] [-R] input\n") 
* input MiniC   program file to compiler  
optional arguments: 
* -h, --help             show this help message and exit 
* -l, --lex              display tokens from lexer 
* -a, --AST              Display AST 
* -D, --dot              Generate AST graph as DOT format 
* -s, --sym              Dump the symbol table 
* -R, --exec             Execute the generated program


